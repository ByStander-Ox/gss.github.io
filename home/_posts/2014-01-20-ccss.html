---
uid: c_101
title: Constraint CSS
subtitle: design like it's 1999
color: b
---
Soon after the W3C introduced Cascading Style Sheets, [Greg Badros](http://www.badros.com/greg/), the author of the Cassowary Constraint Solver & recently retired Facebook VP, proposed [Constraint CSS (CCSS)](http://www.cs.washington.edu/research/constraints/web/ccss-uwtr.pdf) as a general solution for CSS layout.  Little today has changed.  Back in '99 Badros demonstrated *responsive* layouts with CSS that today's designers still can't reproduce without grinding out piles of JavaScript.

The foundation of GSS is a modernized implementation of CCSS.  From CCSS primitives other, more exotic layout API's can and are accomplished.  

## Constraints, the basics

Constraints express relationships between variables that may or may not hold.  You can constrain any numerical style property of an element, not just itâ€™s position & size.  For example, if I want all paragraph tags to have line-height greater than 16px and less than 1/12th the size of the window:

{% highlight css %}

p[line-height] >= 16;
p[line-height] <= ::window[height] / 12;

{% endhighlight %}

or, we could write it as a single chained statement:

{% highlight css %}

16 <= p[line-height] <= ::window[height] / 12;

{% endhighlight %}

or, we could express the same constraints within a CSS ruleset alongside old-school CSS like so:

{% highlight css %}

p {
  color: purple;
  line-height: >= 16;
  line-height: <= ::window[height] / 12;  
}

{% endhighlight %}

of course, you can nest rules too:

{% highlight css %}

.content {
  
  margin-right: == ::parent[margin-right] * -1;
  
  p, blockquote {
    color: purple;
    line-height: >= 16;
    line-height: <= ::window[height] / 12;  
  }
}

{% endhighlight %}

Numbers are treated as pixel values except for properties like:

{% highlight css %}

.sprite {
  z-index: >= #bg[z-index] >= 50;
}

{% endhighlight %}

## Constraints are 2-way

Do not confuse an equality constraint with your everyday variable assignment.  For example, in a vanilla programming paradigm:

{% highlight javascript %}

// vanilla programming

x = y;
y = 10
x = 100;

// x => 1000, y => 10

{% endhighlight %}

x will be 1000, and y will be 10.  With constraint programming, equality constraints are two-way, so:

{% highlight javascript %}

// constraint programming

x == y;
x == 100;
y >= 10;

// x => 100, y => 100

{% endhighlight %}

x and y have a constraint to be equal, so x and y will be 100.  

Constraints are incrementally added to a `solver`, then the solver computes a feasible & optimal solution to all the constraints.  With normal procedural programming, the last assignment overcomes the previous.  But, with constraint solvers like Cassowary, earlier statements are stronger than later ones in the "Constraint Hierarchy".

## Custom Constraint Variables

A custom constraint variable can be created by simply using it in a constraint.

{% highlight css %}

.post {
  width: 6 * [col-size];
}

{% endhighlight %}

This automatically defines a constraint variable called `[col-size]` that can be be used in other constraints.

## Custom Element Constraint Variables

You can create a custom variable for an element by, again, simply using it:

{% highlight css %}

.post[col-size] == .post[line-height] * 3;

{% endhighlight %}

This will automatically create a `[col-size]` variable for each element with the class post, and constrains it to be the same as 3 times that post's line-height.  Don't forget this relationship is 2-way, so further constraining a post's [col-size] can effect it's line-height, which can be remedied using [Stays](#stays) or taking advantage of the "Constraint Hierarchy".

Constraint variables are defined in a global scope, as is right in the constraint-based world.  Internally, a constraint variable for an element is created of the form $ + ELEMENT.ID + [ PROP ].  

## Hardware Accelerated Layout Variables

By default, GSS uses Matrix3D transforms to hardware accelerate the browsers that can.  The following position properties are treated specially:

- `x` or `left`
- `y` or `top`
- `right`
- `bottom`
- `position`
- `center-x`
- `center-y`
- `center`

## Ambiguity

`bottom` & `right` are expressions of position & size, which can lead to ambiguous constraints like:

{% highlight css %}

#box[right] == ::window[right];

/* this is too ambiguous without constraining #box[width] or #box[left] */

{% endhighlight %}

Should the box move it's position to the right or stretch it's width to make it's right edge flush with the window?  A critical best practice is to *fully constrain* an element, in other words, you should adequately specify an element's position & size.  If an element's size & position are not constrained GSS you will likely have unpredictable results. 

## Special Pseudo Selectors

- `::window`
- `::` or `::this`
- `::parent`

The this and parent selectors can only be used in a nested ruleset, as with:

{% highlight css %}

.box {
  width: == ::parent[width];
  line-height: == ::[width] / 12;  /* same as ::this[width] */
}

{% endhighlight %}

**PRO TIP:** parent selectors can be used to "bridge" variables in interesting ways.  A contrived example:

{% highlight css %}
#product {
  
  $col-width: == ::[width] / 12
  $col-left: == ::[left] + ::[$col-width];
  
  .price {
    left:  == ::parent[$col-left];
    width: == ::parent[$col-width];
  }
  
  .description {
    left: == ::parent[$col-left] + ::parent[$col-width];
  }
}
{% endhighlight %}


## Intrinsic Properties

What if we want an paragraph's height to be the *intrinsic* height of it's text content?  We use an intrinsic property!

{% highlight css %}
/* all paragraphs will have a height equal to it's text-height */

p {
  height: == ::[intrinsic-height];
}
{% endhighlight %}


When you add `intrinsic-` before a property, GSS will try to measure that property from the DOM every time it needs to solve for new values, as when a paragraph text-content changes or when the window size changes & you used `::window` somewhere.  GSS defers things to avoid serial DOM read / writes, but reading the DOM can be expensive.

**PRO TIP:** minimize use of intrinsic properties.  For example, best hardcode image width & height in equality constraints if can be known ahead of time.

## Stays

Ambiguity can be largely overcome by declaring more constraints, but what about situations like:

{% highlight css %}

#box[left]  >= 100;
#box[width] >= 100;
#box[right] == ::window[right];

/* the #box's width will stretch */

{% endhighlight %}

Will the `#box` move or stretch to satisfy the last constraint?  Again, the earlier constraint statements are more powerful than later ones, so the box's width would stretch.  You can control this by either changing the order in which the constraints are declared or by using a `stay` like so:

{% highlight css %}
#box[left]  >= 100;
#box[width] >= 100;
@stay(#box[width]);
#box[right] == ::window[right];

/* the #box's position will move */
{% endhighlight %}


Many `stay`s can be declared at once with `@stay([var1],[var2],[var3])`.

## Linear Arithmetic

Cassowary only allows for "Linear Arithmetic" constraints, you can do simple math operations like `+`, `-`, `*` and `/`, but all expressions must be linear (of the form y = mx + b).  Basically, you can add & subtract anything, but you can't multiply or divide two constraint variables.  

{% highlight css %}

/* this is not linear & will throw an error */

#box1[width] / #box1[height] == #box2[width] / #2box[height];

{% endhighlight %}

I wish we could go non-linear, but we can't because math.


## Strength & Weight

TODO...




