---
uid: Layout
title: Position and dimension
subtitle: lay it out like it's 1999
color: b
layout: post
---

<a name="position"></a>
## Positioning

Elements are positioned relative to the scope element, so its top left corner is considered a (0, 0) point. GSS initialized upon `document`, `<html>`, `<body>` or `<head>` position against the `<html>` element. Global properties like `$left`, `$right`, `$scroll-top` and `$bottom` point to respective properties of `::window`.

Cassowary is a general purpose solver, so it does not make any assumptions about the positioning or even geometry. If there's nothing that is bound to absolute values like zero or edges of the screen, the whole layout can be solved to be positioned off-screen. Negative `top` and `left` values is a common gotcha in *underconstrained* systems.

### Top

{% highlight css %}

#someElm[top] == 20;

/* equivalent to : */
#someElm[y] == 20;

{% endhighlight %}

Place the top of the element 20px from the top of the page.

### Bottom

{% highlight css %}

#someElm[bottom] == 100;

/* equivalent to : */
#someElm[bottom] == #someElm[top] + #someElm[height];

{% endhighlight %}

Place the bottom of the element 100px from the top of the page.

### Left

{% highlight css %}

#someElm[left] == 20;

/* equivalent to : */
#someElm[x] == 20;

{% endhighlight %}

Place the left of the element 20px from the left of the page.

### Right

{% highlight css %}

#someElm[right] == 100;

/* equivalent to : */
#someElm[rigth] == #someElm[left] + #someElm[width];

{% endhighlight %}

Place the right of the element 100px from the left of the page.

### position

{% highlight css %}
#someElm[position] == 100;

/* equivalent to : */
#someElm[top] == 100;
#somElm[left] == 100;

{% endhighlight %}

### top-left, top-right

{% highlight css %}
#someElm[top-left] == 100;
#otherElm[top-right] == 200;

/* equivalent to : */
#someElm[top] == 100;
#someElm[left] == 100;
#otherElm[top] == 200;
#otherElm[right] == 200;

{% endhighlight %}

Position the `#someElm` top-left corner to be at 100px from the top-left of the page.
Same thing for `#otherElm` excepts its the top-right corner that's been position 200px
from the top-left of the page.

### bottom-left, bottom-right

{% highlight css %}
#someElm[bottom-left] == 100;
#otherElm[bottom-right] == 200;
{% endhighlight %}

Position the `#someElm` bottom-left corner to be at 100px from the top-left of the page.
Same thing for `#otherElm`, excepts its the bottom-right corner that's been position 200px
from the top-left of the page.

### center-x, cx

{% highlight css %}
#someElm[center-x] == 100;

/* you can also use the condense syntax: */
#someElm[cx] == 100;

/* center-x will expand in the following constraints */
#someElm[left] + #someElm[width] / 2 == 100;

{% endhighlight %}

Horizontally place the horizontal center of the element at 100px from the left of the page.

### center-y, cy

{% highlight css %}

#someElm[center-y] == 100;

/* you can also use the condense syntax: */
#someElm[cy] == 100;

/* center-y will expand in the following constraints */
#someElm[top] + #someElm[height] / 2 == 100;

{% endhighlight %}

Place the vertical center of the element 100px from the top of the page.

### Center

{% highlight css %}
#someElm[center] == 100;
{% endhighlight %}

`center` is a 2d property shortcut for constraining both `center-x` and `center-y` at once.

<a name="relativepositionning"></a>


### Relative positioning

Elements that have parents with `position: relative` declared in CSS stylesheet will compute their position ignoring that declaration. Visually the constraints will hold, but the actual `top` and `left` styles assigned for each element will account for the relative positioning.

When `position


{% highlight css %}

<section class="relative-container" style="position: relative">
  <div class="container"></div>
</section>

<section class="relative-container" id="section-two" style="position: relative">
  <div class="container"></div>
</section>

<style type="text/gss">

.relative-container {
  top: == 0;
  left: == 0;

  .container {
    @v |-(&)-| in(^) gap(10);
    height: == 100;
    width: == 100;
  }
}

</style>

{% endhighlight %}

In this example, the `top` and `left` are constrained to be zero wich is the top-left corner of section
elements. By doing so, all position' constraints will be calculated relative to the section element.

With the `position: relative` declared in the `style` attribute, GSS will solve independently each sections which
should results in better performance. <a href="http://codepen.io/thegridgssdocs/pen/pvwaNN" target="_blank">Live example.</a>


## Dimensions
GSS provides property to constrain the dimension of an element. We've already saw the `width` and `height`.
GSS provides syntax sugar called 2d properties to constrain both height and width of an element as a single property.

{% highlight css %}

.selectorA {
  size: == 200;
}

{% endhighlight %}

## Intrinsic values
When you want to constrain the position of an element GSS needs to know the dimension of the element. For example how could
GSS position an element using the bottom-right property without knowing the height and width of that element.

One way to solve this, would be to constrain the dimension of the element. But what if it had text in it? You'll then need to know the
exact width and height require to display the text. What if that text is dynamic? The element might also be styled using CSS and you
want to get the dimensions of that styling.

In most cases, the constraints will provide those values indirectly regardless of the element's contents. It is possible to make
GSS measure content the values coming from DOM or CSS - be it text, or blocks styled with css.

GSS provides the `intrinsic-` properties which defers to CSS the dimension styling of the element and instruct GSS to measure
the elements using that styling.

{% highlight css %}

  .selectorA {
    width: == &[intrinsic-width];
    height: == &[intrinsic-height];
  }

  .selectorB {
    size: == &[intrinsic-size];
  }

{% endhighlight %}

Once an intrinsic property is used on an element, GSS will evaluate other constraints you defined on the same property but the
calculated value will not be assign to the property because `intrinsic` property makes the property read-only.

For example, if we add a `width` constraint on `.selectorA`, that constraint will be
evaluated by GSS but not applied to the element since `intrinsic-*` have precendence over all other constraints.


## Read next
If you come from the CCSS guide [continue your learning of CCSS](/guides/ccss/#position)

Learn how to use [CCSS constraints](/guides/ccss)

GSS provides conditionnal statements to allow you to do responsive design. Read our [@if @else guide](/guides/ifelse) to learn more.

With only CCSS constraints at your disposal, constraining common layout scenarios quickly becomes tedious. Read our
[VFL guide](/guides/ifelse) to learn how to more efficiently constrain your layout.
