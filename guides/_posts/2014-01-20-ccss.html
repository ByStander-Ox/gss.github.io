---
uid: CCSS
title: Constraint CSS
subtitle: lay it out like it's 1999
color: b
layout: post
---

<ul class="large-list cols-2">
  <li><a href="#basicconstraint">Constraints, the basics</li>
  <li><a href="#selectors">Selectors</a></li>
  <li><a href="#rulesets">Rulesets</a></li>
  <li><a href="#scope">Scope</a></li>
  <li><a href="#position">Positionning elements</a></li>
  <li><a href="#virtuals">Virtuals</a></li>
</ul>


Soon after the W3C introduced Cascading Style Sheets, [Greg Badros](http://www.badros.com/greg/), the author of the Cassowary Constraint
Solver & [recently retired Facebook VP](http://allthingsd.com/20130920/facebook-engineering-and-products-vp-greg-badros-to-leave-company/),
proposed [Constraint CSS (CCSS)](http://www.cs.washington.edu/research/constraints/web/ccss-uwtr.pdf) as a general solution for CSS layout.
Back in '99 Badros demonstrated *responsive* layouts with CCSS that today's designers still can't reproduce without grinding out piles of JavaScript.
For more than a decade, no one seemed to take notice outside academia... Until Apple implemented Cassowary & Greg's pioneering concepts in its new
AutoLayout engine with the launch of OS X Lion. Despite the evolutionary leap for app developers, web designer's have had to settle
with [float-based](http://www.sitepoint.com/give-floats-the-flick-in-css-layouts/) & table-based layouts that have remained unimproved to this day.

> "We should contemplate how very, very far behind the web platform is in making it delightful to build the sorts of things that are work-a-day in native environments." <a href="http://infrequently.org/2012/02/misdirection/">Alex Russell</a>

The foundation of GSS is a modernized implementation of CCSS.  From CCSS primitives other, more exotic layout API's can and are accomplished.

<a name="basicconstraint"></a>
## Constraints, the basics

Constraints express [relationships between variables](#constraintsaretwoway) that [may or may not hold](#mayormaynothold).
Any numeric property of an element can be constrained, not just position & size.

In the following example, all paragraph tags are constrained to have line-height greater than 16px and
less than 1/12th the size of the window:

{% highlight css %}

p[line-height] >= 16;
p[line-height] <= ::window[height] / 12;

{% endhighlight %}

### Constraint declaration

The syntax for declaring a constraint is as follows:

`p[line-height] >= 16;`

+ `p` is the selector. This constraint will apply to every `p` tag in the page.
+ `[]` is the property accessor syntax.
+ `line-height` is the property for which a value will be calculated by GSS.
+ `>=` defines an inequality constraint. You can declare inequality and equality constraint.
+ `16` is the numerical value for the constraint in pixels (the default unit of measurement in GSS).

<a href="http://codepen.io/cbchouinard/pen/OPmdVL" target="_blank">Live example</a>

<a name="constraintsaretwoway"></a>
### Constraints are two-way
Do not confuse an equality constraint with your everyday variable assignment. For example, in a vanilla programming paradigm:

{% highlight javascript %}

// vanilla programming

x = y;
y = 10
x = 100;

// x => 100, y => 10

{% endhighlight %}

x will be 100, and y will be 10.  With constraint programming, equality constraints are two-way, so:

{% highlight javascript %}

// constraint programming

x == y;
x == 100;
y >= 10;

// x => 100, y => 100

{% endhighlight %}

x and y have a constraint to be equal, so x and y will be 100.

Constraints are incrementally added to a `solver`, then the solver computes a feasible & optimal solution to all the constraints.
Constraint programming focuses on intentions, not implementation. This makes constraint solver a perfect fit for empowering declarative languages like CSS. 

Regular imperative programming approach focuses on the implementation instead, making programmer solve the problems.

<a name="mayormaynothold"></a>
### Constraints May or may not hold
GSS will find the best solution that satisfies the defined constraints. It uses uses "soft" constraints,
which means that it is preferred but not required that certain constraints be satisfied.

For example:

{% highlight css %}

#gss[width] == 200;
#cassowary[width] == 200;
#gss[width] + #cassowary[width] == 350;

{% endhighlight %}

`#GSS` and `#cassowary` elements are constrained to have width of 200px initially, and then the sum of those two is set to equal 350px. In this case, one of these
two constraints will not hold. <a href="http://codepen.io/cbchouinard/pen/XJROdV" target="_blank">Live example.</a>

<a name="strengths"></a>
## Strengths

It is possible to influence the solution by prioritizing the constraints with strengths.

Stronger constraints completely overcome weaker ones - this is the phenomena of the [Constraint Hierarchy](http://www.cs.washington.edu/research/constraints/theory/hierarchies-92.html).  Strengths are declared in the same fashion of CSS's `!important`:

{% highlight css %}

/* Stronger constraints are more important */

#light[years] == 100 !weak;
#light[years] == 200 !medium;
#light[years] == 300 !strong;

/* #light[years] will be 300 */

{% endhighlight %}

There are 4 levels of built-in strength:

- `!weak`
- `!medium` (default)
- `!strong`
- `!require`


In a [previous example](#mayormaynothold),
strengths assigned to constraints allow individual `width` constraints to overcome the sum constraint: <a href="http://codepen.io/cbchouinard/pen/bNRbQg" target="_blank">Live example.</a>

#### !require strength
`!require` is a special strength that guarantees the constraint will hold, otherwise everything breaks.

**Pro Tip** Use `!require` carefully & sparingly. `!require`'s quickly lead to systems where
all required constraints cannot be satisfied in which case the GSS engine will throw an error.

For example, the following GSS constraints will be unsolvable and thus throw an exception:

{% highlight css %}

#gss[width] == 200 !require;
#cassowary[width] == 200 !require;
#gss[width] + #cassowary[width] == 350 !require;

{% endhighlight %}

We're asking GSS to find a solution where the widths of the #gss and #cassowary element must be 200px
and their sum must be 350px which is impossible.

### Constraints order
Generally speaking, later constraint declarations of the same strength are more powerful than earlier ones. There are exceptions to this behavior,
as we'll see in the following sections.

In a [previous example](#mayormaynothold)  with conflicting strengths, altered order of constraints yields a
different result. <a href="http://codepen.io/cbchouinard/pen/rawBRr" target="_blank">Live example.</a>

<a name="lineararithmetic"></a>
## Linear Arithmetic

Cassowary, which is the constraints solving algorithm used by GSS, can only compute "Linear Arithmetic" constraints. Simple math operations like `+`, `-`, `*` and `/` are all supported, but the expressions must be linear (of the form `y = mx + b`).  Basically, you can do everything except division and multiplication of two constrained variables.
<a href="http://codepen.io/cbchouinard/pen/MYvOWO" target="_blank">Live example.</a>

{% highlight css %}

/* this is not linear & will throw an error */

#box1[width] / #box2[height] == varX;

{% endhighlight %}

## Units of measurement
The default unit of measurements is pixel. GSS also supports the following units:

{% highlight css %}
em /* use the font size of the element */
rem /* use the font size of the html element */
vh /* viewport height */
vw /* viewport width */
vmax /* the greatest value between vh or vw */
vmin /* the lowest value between vh or vw */
cm /* centimeter */
mm /* millimeter */
in /* inches */
{% endhighlight %}

<a name="selectors"></a>
## Selectors

Selector is a query over a tree of HTML elements. They determine which elements are affected by the constraint. 

{% highlight css %}
// elements with tag name div within element with #something id
(#something div)[width] == 100;
{% endhighlight %}

There are many kinds of selectors, so there is a dedicated guide for them. We invite you to read all of it since there are some useful
information at the bottom: [GSS Selectors Guide](/guides/selectors) \*

\* Note that this guide is refering to [rulesets](rulesets) which are covered next.

<a name="rulesets"></a>
## Rulesets

Rulesets allow multiple constraints to be defined over a single selector

{% highlight css %}
  .selector {
    width: == 100;
  }
{% endhighlight %}

Within a ruleset, constraints are defined on properties using the same syntax as CSS using colon `:` followed by a equality sign.

Rulesets can be nested:

{% highlight css %}
section > article {
   .someclass {
       width: == 100;
    }
}

// is equivalent of
(section > article .someclass)[width] == 100;

{% endhighlight %}

CSS properties can be defined in the rulesets just like in CSS:

{% highlight css %}
div {
   background-color: green;
   width: <= 200;
}
{% endhighlight %}

### Selectors within rulesets

Selectors within ruleset body are scoped to the elements matching the ruleset selector. For example:

{% highlight css %}
div {
  width: <= .widget[width];
}
{% endhighlight %}

`<div>` elements will constrain their width to descendants having the class name `widget` but only if they have any.
<a href="http://codepen.io/cbchouinard/pen/yyXPyK" target="_blank">Live example.</a>


`$` combinator makes selectors in ruleset body apply to the root of a document ignoring the nesting:

{% highlight css %}
div {
  width: <= ($ #elm)[width];
}
{% endhighlight %}

`^` combinator makes selectors in ruleset body apply to the elements selected by the parent ruleset:

In this following example '^' will move up to the current `.container` element and will search its descendants
for an element with `elm` id. <a href="http://codepen.io/cbchouinard/pen/yyXPej" target="_blank">Live example.</a>

{% highlight css %}

.container {
  div {
    width: <= (^ #elm)[width];
  }
}

{% endhighlight %}


## Properties

All the previous examples constrained CSS properties like `width` or `line-height`. It is possible to
constrain custom properties that are not recognized by CSS, but can used in GSS constraints over known CSS properties.

`&` combinator refers to current element matching the ruleset selector. It is implied by the use of `width: ==` property notation.

{% highlight css %}
.container {
  width: == #elm[width];
}

/* It is the same as: */

.container {
  &[width] == #elm[width];
}

{% endhighlight %}

Properties on special combinators like `&`, `$` or `^` may omit square brackets:

{% highlight css %}

body {
  .container {
    &width == ^width;
  }
}

{% endhighlight %}


{% highlight css %}

.post {
  custom-property: == &line-height * 3;
}

/* equals to */

.post[custom-property] == .post[line-height] * 3;

{% endhighlight %}

This will automatically create a `custom-property` for each element having a `.post` class. The element's `custom-property` will be constrained to be thrice its own `line-height`.

Because of the 2-way binding, changing either `custom-property` or `line-height` will affect the other property of the element.

<a name="variables"></a>
## Variables

Variables are special kind of properties that can be accessed from inner scopes. 

In addition to properties, GSS allows you to declare variables. Variabled declared in outer scoped.

{% highlight css %}

<style text='text/gss'>
varX == 100;

.className {
  width: == varX;
  varY == &[height];

  #div {
    width: == varX;
  }
}
</script>

{% endhighlight %}

Variables are hoisted and can be access from child' scopes. You can learn more about variable's
hoisting and scoping in [scope section](#scope).

Variable can be declare with `[]`. There's no difference between the two syntaxes:

{% highlight css %}

[varX] == 100; /* equivalent to varX == 100; */

{% endhighlight %}

### Variables in constructor
When instantiating GSS, you can provide global variable values to the constructor:

{% highlight html %}

<script src="/bower_components/gss/dist/gss.js"></script>
<script type="text/javascript">
  GSS.document = new GSS(document, {"some-width": 400, "some-height": 150});
</script>

<style type="text/gss">

  section[width] == $some-width;
  section[height] == $some-height;

</style>

{% endhighlight %}

Since they are global variables, don't forget to access them with `$`. <a href="http://codepen.io/cbchouinard/pen/pvWMJV" target="_blank">Live example.</a>

## CSS property name
Now that we've seen properties and variables, you can do some interesting things by using CSS properties as variables. For example you
can declare constraints on CSS properties of parent scope:

{% highlight css %}
<style text='text/gss'>
varX = 100;

.className {
  width == varX;

  #someElm {
    width == &[height];
  }
}
</script>

{% endhighlight %}

Since `width` in the `.className` ruleset is used as a variable and not a property, it is hoisted. Therefore,
the constraint on the `width` declared in `#someElm` ruleset will affect the `.className` width and not the
`#someElm` `width`.

<a name="scope"></a>
## Scope
GSS will scope variables base on their top most location. A variable can be scoped
within a style element, within a gss style file, within a ruleset or globally for the entire document.

{% highlight css %}
  .selector {
    width: == 100;
  }
{% endhighlight %}

In the following example, `varX` used within `.selector` will be hoisted since it is declare in a parent scope.
The order doesn't matter, GSS will search for the top most variable declaration.

{% highlight css %}
  .selector {
    width: == varX;
  }

  varX == 100;
{% endhighlight %}

#### Style sheet or GSS file
When declaring a variable at the root of a `style` block, the variable will be scoped to that `style` block.
Which means, you'll not have access to that variable from other `style` block. In the following example, `varX`
variables are independant from each other since they belong in two seperate scope.

{% highlight css %}
<style type="text/gss">
  varX == 100;
  #elm1[width] == varX;
</style>

<style type="text/gss">
  varX == 200;
  #elm2[width] == varX;
</style>
{% endhighlight %}

In this example, `#elm1` will have a width of 100px and `#elm2` will have a width of 200px.
The two `varX` are in distinct scope and are therefore indenpendant from each other.
<a href="http://codepen.io/cbchouinard/pen/EaXmRp" target="_blank">Live example.</a>

Global variable, accessed with `$`, are accessible accross stylesheets. In the previous example, if we would have use a
global variable for `varX` then the two constrained elements would have had the
same width. <a href="http://codepen.io/cbchouinard/pen/yyoxxm" target="_blank">Live example.</a>

The same scoping logic applies to external GSS files.

#### Ruleset
Variables defined inside a ruleset are scoped to the element(s) matching the ruleset's selector.

{% highlight css %}
.someClass {
  varX == 100;
  width: == varX;
}

.someOtherClass {
  varX == 200;
  width: == varX;
}
{% endhighlight %}

In this example, each `varX` is scoped to the element(s) matching the ruleset's selector. Which means, a variable
`varX` will be defined for each element matching the ruleset's selector. Therefore, if the same element matches both
ruleset selectors, then varX for that element will be equal to the value specified in the later ruleset.
<a href="http://codepen.io/cbchouinard/pen/XJgRPq" target="_blank">Live example.</a>

### Hoisting
When using a variable in GSS, before creating the variable, GSS will look on parent
scopes to see if there's an existing variable with the same name.

For example:

{% highlight css %}
div {
  varX == 40;

  .someClass {
    width: == varX;

    .someNestedClass {
        varY == 45;
        width: == varY;
        top: == varX;
    }

    .someOtherNestedClass {
        varY == 60;
        height: == varY;
        width: == varX;
      }
  }
}
{% endhighlight %}

In this case, `varX` used in the nested rulesets is hoisted from the `div` scope. Internally, GSS will go up the
scope tree using the parent pseudo selector `^varX`, if no variable is found at that level, GSS will do `^^varX`
and so on until it finds a variable or until it reach the root scope, at which point, if GSS didn't find a variable it
will create a new one on the scope where it was declared.

`varY` is been declared in two sibling rulesets. In this case, two distinct variables will be created and scoped to their
respective ruleset. <a href="http://codepen.io/cbchouinard/pen/zxzwXJ" target="_blank">Live example.</a>

#### Properties are not hoisted
Only variables are hoisted. Since properties aren't hoisted, they cannot be access from child scope.

{% highlight css %}
div {
  varX: == 40; /* property constraint */
  varY == 45; /* variable constraint */

  .someClass {
    /* varX is not hoisted here since on the parent scope varX is a property. */
    /* A new variable varX is there created and scoped to .someClass */
    width: == varX;

    .someNestedClass {
      /* varY is hoisted from the div scope since it's scoped at that level */
      width: == varY;
      /* varX here is the .someClass varX scoped variable */
      top: == varX;
    }
  }
}
{% endhighlight %}

#### Property and variable with the same name
If you declare a property having the same name as a hoisted variable, you need to use the `&` selector to
access the property otherwise you'll get the hoisted variable.

{% highlight css %}
div {
  varX == 50;

  .className {
    varX: == 60;
    width: == &[varX]; /*  60 since we are using the property varX */
  }
}
{% endhighlight %}


### Global variables
Global variables can be define using the `$` symbol.

{% highlight css %}
$var1 == 100;
{% endhighlight %}

You can access globally scoped variables from everywhere using the global operator `$`. If you declare a variable at the
root of a stylesheet without the `$` that variable will be accessible through hoisting but only for constraints within t
hat stylesheet. By declaring it with `$`, you can access the variable from all `style` blocks or GSS files in the current page.



<a name="position"></a>
## Positions constraints
Position in GSS will always be relative to the element in which you instantiated the GSS engine. For example,
if you instantiate the GSS engine in the `html`, `head` or `body` element, then elements will be `absolute` positionned
from `left = 0, top = 0`. It's also possible to [positioning element relative to a container element](#relativepositionning)
as well see later.

GSS provide properties to quickly constrain the dimensions and positions of elements. For example, assuming the `body` is the root
element for GSS, the `$[top-left]` property of the root element will be `x = left = 0, y = top = 0`.

If you're under constraining your elements, GSS might find a solution where negative coordinates are the solution. In that
case you need to declare more constraints. For example, you could prevent that from happening by contraining the edges of the
elements to the edge of `::window`.

The following documentation assume the GSS engine was declared in the `body` element so we are positionning elements from the
top-left corner of the page `left=0, top=0`.

### Top

{% highlight css %}

#someElm[top] == 20;

/* equivalent to : */
#someElm[y] == 20;

{% endhighlight %}

Place the top of the element 20px from the top of the page.

### Bottom

{% highlight css %}

#someElm[bottom] == 100;

/* equivalent to : */
#someElm[bottom] == #someElm[top] + #someElm[height];

{% endhighlight %}

Place the bottom of the element 100px from the top of the page.

### Left

{% highlight css %}

#someElm[left] == 20;

/* equivalent to : */
#someElm[x] == 20;

{% endhighlight %}

Place the left of the element 20px from the left of the page.

### Right

{% highlight css %}

#someElm[right] == 100;

/* equivalent to : */
#someElm[rigth] == #someElm[left] + #someElm[width];

{% endhighlight %}

Place the right of the element 100px from the left of the page.

### position

{% highlight css %}
#someElm[position] == 100;

/* equivalent to : */
#someElm[top] == 100;
#somElm[left] == 100;

{% endhighlight %}

### top-left, top-right

{% highlight css %}
#someElm[top-left] == 100;
#otherElm[top-right] == 200;

/* equivalent to : */
#someElm[top] == 100;
#someElm[left] == 100;
#otherElm[top] == 200;
#otherElm[right] == 200;

{% endhighlight %}

Position the `#someElm` top-left corner to be at 100px from the top-left of the page.
Same thing for `#otherElm` excepts its the top-right corner that's been position 200px
from the top-left of the page.

### bottom-left, bottom-right

{% highlight css %}
#someElm[bottom-left] == 100;
#otherElm[bottom-right] == 200;
{% endhighlight %}

Position the `#someElm` bottom-left corner to be at 100px from the top-left of the page.
Same thing for `#otherElm`, excepts its the bottom-right corner that's been position 200px
from the top-left of the page.

### center-x, cx

{% highlight css %}
#someElm[center-x] == 100;

/* you can also use the condense syntax: */
#someElm[cx] == 100;

/* center-x will expand in the following constraints */
#someElm[left] + #someElm[width] / 2 == 100;

{% endhighlight %}

Horizontally place the horizontal center of the element at 100px from the left of the page.

### center-y, cy

{% highlight css %}

#someElm[center-y] == 100;

/* you can also use the condense syntax: */
#someElm[cy] == 100;

/* center-y will expand in the following constraints */
#someElm[top] + #someElm[height] / 2 == 100;

{% endhighlight %}

Place the vertical center of the element 100px from the top of the page.

### Center

{% highlight css %}
#someElm[center] == 100;
{% endhighlight %}

`center` is a 2d property shortcut for constraining both `center-x` and `center-y` at once.

<a name="relativepositionning"></a>
### Relatively positionned parents.

GSS deals with relative parents in two distinct way. One being when the parent `position: relative` property
is declared in a CSS ruleset, the other is when the `position: relative` is declared in the `style` attribute of
the element.

#### position: relative in ruleset
Even if the elements your constraining are placed within an element having the CSS property `position: relative`,
the constraints will calculate absolute position agains the top-left corner of the root element.

If you look at the calculated values, you'll see that they account for their relative parent position but are
positionned according to the top-left of the root element.


#### position: relative in style attribute
When you are dealing with a very large page composed of multiples elements, GSS needs to know the position and dimension of
each element in order to find a solution to the constraints you've defined.

It is possible to localize computations within dedicated containers and rely on CSS to lay them out in the page.
Sections with `position: relative` set in the `style` attribute will be solved separately, leading to better performance.

{% highlight css %}

<section class="relative-container" style="position: relative">
  <div class="container"></div>
</section>

<section class="relative-container" id="section-two" style="position: relative">
  <div class="container"></div>
</section>

<style type="text/gss">

.relative-container {
  top: == 0;
  left: == 0;

  .container {
    @v |-(&)-| in(^) gap(10);
    height: == 100;
    width: == 100;
  }
}

</style>

{% endhighlight %}

In this example, the `top` and `left` are constrained to be zero wich is the top-left corner of the section
element. By doing so, all position' constraints will be calculated relative to the section element.

With the `position: relative` declared in the `style` attribute, GSS will solve independently each sections which
should results in better performance. <a href="http://codepen.io/cbchouinard/pen/pvwaNN" target="_blank">Live example.</a>

## Dimensions
GSS provides property to constrain the dimension of an element. We've already saw the `width` and `height`.
GSS provides syntax sugar called 2d properties to constrain both height and width of an element as a single property.

{% highlight css %}

.selectorA {
  size: == 200;
}

{% endhighlight %}

## Intrinsic values
When you want to constrain the position of an element GSS needs to know the dimension of the element. For example how could
GSS position an element using the bottom-right property without knowing the height and width of that element.

One way to solve this, would be to constrain the dimension of the element. But what if it had text in it? You'll then need to know the
exact width and height require to display the text. What if that text is dynamic? The element might also be styled using CSS and you
want to get the dimensions of that styling.

In most cases, the constraints will provide those values indirectly regardless of the element's contents. It is possible to make
GSS measure content the values coming from DOM or CSS - be it text, or blocks styled with css.

GSS provides the `intrinsic-` properties which defers to CSS the dimension styling of the element and instruct GSS to measure
the elements using that styling.

{% highlight css %}

  .selectorA {
    width: == &[intrinsic-width];
    height: == &[intrinsic-height];
  }

  .selectorB {
    size: == &[intrinsic-size];
  }

{% endhighlight %}

Once an intrinsic property is used on an element, GSS will evaluate other constraints you defined on the same property but the
calculated value will not be assign to the property because `intrinsic` property makes the property read-only.

For example, if we add a `width` constraint on `.selectorA`, that constraint will be
evaluated by GSS but not applied to the element since `intrinsic-*` have precendence over all other constraints.

<a name="virtuals"></a>
## Virtuals
Virtuals are rectangles you define in GSS that don't have a representation in the DOM. You can contrain DOM element
and other virtuals against the dimension and position of virtuals. Virtual are a practical way to constrain a group of element
without the need for a DOM container element.

{% highlight css %}

  "area" {
    size: == ::window[size] / 2;
    center: == ::window[center];
  }

  #elmA[top-left] == "area"[top-left];
  #elmB[bottom-right] == "area"[top-right];

{% endhighlight %}

As you can see from the previous example, we are constraining `#elmA` and `#elmB` against the virtual element.
<a href="http://codepen.io/cbchouinard/pen/WbOWgB" target="_blank">Live example.</a>

In regards of constraining dimensions and positions, virtuals are no different from DOM element in the sens that you can
declare constraints on them as shown previously. The main difference is that since they don't exist in the DOM, they are
not stylable with CSS. Doing the following will have no effect:

{% highlight css %}

"area" {
  /* Styling virtuals have no effect since they don't exist in the DOM */
  background-color: blue;
}

{% endhighlight %}

### Virtual hoisting
Virtuals follow the same scoping rules as variables. You can do the following:

{% highlight css %}

.className {
  "area"[size] == 200;

  #someElm > div {
    width: == "area"[width]; /* "area" will be hoisted from the .className scope */
  }
}

{% endhighlight %}


### Virtual splat
Virtual splats allow you to create a grid of virtuals. For example, if you want to split the viewport in four equally dimensioned
virtuals you can do the following:

{% highlight css %}


"area1...4" {
  width: == ::window[width] / 2;
  height: == ::window[height] / 2;
}

"area1...2" {
  top: == 0;
  right: == &:next[left];
}

"area3...4" {
  right: == &:next[left];
}

"area1", "area3" {
  top: == &:previous[bottom];
}
"area2", "area4" {
  top: == &:previous[bottom];
}

{% endhighlight %}

Using those virtual boxes, you can now constrain DOM elements against those four boxes. <a href="http://codepen.io/cbchouinard/pen/VYzOPx" target="_blank">Live example.</a>


## Read next
GSS provides conditionnal statements to allow you to do responsive design. Read our [@if @else guide](/guides/ifelse) to learn more.

With only CCSS constraints at your disposal, constraining common layout scenarios quickly becomes tedious. Read our
[VFL guide](/guides/ifelse) to learn how to more efficiently constrain your layout.
