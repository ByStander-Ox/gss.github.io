---
uid: CCSS
title: Constraint CSS
subtitle: lay it out like it's 1999
color: b
layout: post
---

<ul class="large-list cols-2">
  <li><a href="#basicconstraint">Constraints, the basics</li>
  <li><a href="#selectors">Selectors</a></li>
  <li><a href="#rulesets">Rulesets</a></li>
  <li><a href="#scope">Scope</a></li>
  <li><a href="#position">Positionning elements</a></li>
  <li><a href="#virtuals">Virtuals</a></li>
</ul>


Soon after the W3C introduced Cascading Style Sheets, [Greg Badros](http://www.badros.com/greg/), the author of the Cassowary Constraint
Solver & [recently retired Facebook VP](http://allthingsd.com/20130920/facebook-engineering-and-products-vp-greg-badros-to-leave-company/),
proposed [Constraint CSS (CCSS)](http://www.cs.washington.edu/research/constraints/web/ccss-uwtr.pdf) as a general solution for CSS layout.
Back in '99 Badros demonstrated *responsive* layouts with CCSS that today's designers still can't reproduce without grinding out piles of JavaScript.
For more than a decade, no one seemed to take notice outside academia... Until Apple implemented Cassowary & Greg's pioneering concepts in its new
AutoLayout engine with the launch of OS X Lion. Despite the evolutionary leap for app developers, web designer's have had to settle
with [float-based](http://www.sitepoint.com/give-floats-the-flick-in-css-layouts/) & table-based layouts that have remained unimproved to this day.

> "We should contemplate how very, very far behind the web platform is in making it delightful to build the sorts of things that are work-a-day in native environments." <a href="http://infrequently.org/2012/02/misdirection/">Alex Russell</a>

The foundation of GSS is a modernized implementation of CCSS.  From CCSS primitives other, more exotic layout API's can and are accomplished.

<a name="basicconstraint"></a>
## Constraints, the basics

Constraints express [relationships between variables](#constraintsaretwoway) that [may or may not hold](#mayormaynothold).
Any numeric property of an element can be constrained, not just position & size.

In the following example, all paragraph tags are constrained to have line-height greater than 16px and
less than 1/12th the size of the window:

{% highlight css %}

p[line-height] >= 16;
p[line-height] <= ::window[height] / 12;

{% endhighlight %}

### Constraint declaration

The syntax for declaring a constraint is as follows:

`p[line-height] >= 16;`

+ `p` is the selector. This constraint will apply to every `p` tag in the page.
+ `[]` is the property accessor syntax.
+ `line-height` is the property for which a value will be calculated by GSS.
+ `>=` defines an inequality constraint. You can declare inequality and equality constraint.
+ `16` is the numerical value for the constraint in pixels (the default unit of measurement in GSS).

<a href="http://codepen.io/cbchouinard/pen/OPmdVL" target="_blank">Live example</a>

<a name="constraintsaretwoway"></a>
### Constraints are two-way
Do not confuse an equality constraint with your everyday variable assignment. For example, in a vanilla programming paradigm:

{% highlight javascript %}

// vanilla programming

x = y;
y = 10
x = 100;

// x => 100, y => 10

{% endhighlight %}

x will be 100, and y will be 10.  With constraint programming, equality constraints are two-way, so:

{% highlight javascript %}

// constraint programming

x == y;
x == 100;
y >= 10;

// x => 100, y => 100

{% endhighlight %}

x and y have a constraint to be equal, so x and y will be 100.

Constraints are incrementally added to a `solver`, then the solver computes a feasible & optimal solution to all the constraints.
Constraint programming focuses on intentions, not implementation. This makes constraint solver a perfect fit for empowering declarative languages like CSS. 

Regular imperative programming approach focuses on the implementation instead, making programmer solve the problems.

<a name="mayormaynothold"></a>
### Constraints May or may not hold
GSS will find the best solution that satisfies the defined constraints. It uses uses "soft" constraints,
which means that it is preferred but not required that certain constraints be satisfied.

For example:

{% highlight css %}

#gss[width] == 200;
#cassowary[width] == 200;
#gss[width] + #cassowary[width] == 350;

{% endhighlight %}

`#GSS` and `#cassowary` elements are constrained to have width of 200px initially, and then the sum of those two is set to equal 350px. In this case, one of these
two constraints will not hold. <a href="http://codepen.io/cbchouinard/pen/XJROdV" target="_blank">Live example.</a>

<a name="strengths"></a>
## Strengths

It is possible to influence the solution by prioritizing the constraints with strengths.

Stronger constraints completely overcome weaker ones - this is the phenomena of the [Constraint Hierarchy](http://www.cs.washington.edu/research/constraints/theory/hierarchies-92.html).  Strengths are declared in the same fashion of CSS's `!important`:

{% highlight css %}

/* Stronger constraints are more important */

#light[years] == 100 !weak;
#light[years] == 200 !medium;
#light[years] == 300 !strong;

/* #light[years] will be 300 */

{% endhighlight %}

There are 4 levels of built-in strength:

- `!weak`
- `!medium` (default)
- `!strong`
- `!require`


In a [previous example](#mayormaynothold),
strengths assigned to constraints allow individual `width` constraints to overcome the sum constraint: <a href="http://codepen.io/cbchouinard/pen/bNRbQg" target="_blank">Live example.</a>

#### !require strength
`!require` is a special strength that guarantees the constraint will hold, otherwise everything breaks.

**Pro Tip** Use `!require` carefully & sparingly. `!require`'s quickly lead to systems where
all required constraints cannot be satisfied in which case the GSS engine will throw an error.

For example, the following GSS constraints will be unsolvable and thus throw an exception:

{% highlight css %}

#gss[width] == 200 !require;
#cassowary[width] == 200 !require;
#gss[width] + #cassowary[width] == 350 !require;

{% endhighlight %}

We're asking GSS to find a solution where the widths of the #gss and #cassowary element must be 200px
and their sum must be 350px which is impossible.

### Constraints order
Generally speaking, later constraint declarations of the same strength are more powerful than earlier ones. There are exceptions to this behavior,
as we'll see in the following sections.

In a [previous example](#mayormaynothold)  with conflicting strengths, altered order of constraints yields a
different result. <a href="http://codepen.io/cbchouinard/pen/rawBRr" target="_blank">Live example.</a>

<a name="lineararithmetic"></a>
## Linear Arithmetic

Cassowary, which is the constraints solving algorithm used by GSS, can only compute "Linear Arithmetic" constraints. Simple math operations like `+`, `-`, `*` and `/` are all supported, but the expressions must be linear (of the form `y = mx + b`).  Basically, you can do everything except division and multiplication of two constrained variables.
<a href="http://codepen.io/cbchouinard/pen/MYvOWO" target="_blank">Live example.</a>

{% highlight css %}

/* this is not linear & will throw an error */

#box1[width] / #box2[height] == varX;

{% endhighlight %}

## Units of measurement
The default unit of measurements is pixel. GSS also supports the following units:

{% highlight css %}
em /* use the font size of the element */
rem /* use the font size of the html element */
vh /* viewport height */
vw /* viewport width */
vmax /* the greatest value between vh or vw */
vmin /* the lowest value between vh or vw */
cm /* centimeter */
mm /* millimeter */
in /* inches */
{% endhighlight %}

<a name="selectors"></a>
## Selectors

Selector is a query over a tree of HTML elements. They determine which elements are affected by the constraint. 

{% highlight css %}
// elements with tag name div within element with #something id
(#something div)[width] == 100;
{% endhighlight %}

There are many kinds of selectors, so there is a dedicated guide for them. We invite you to read all of it since there are some useful
information at the bottom: [GSS Selectors Guide](/guides/selectors) \*

\* Note that this guide is refering to [rulesets](rulesets) which are covered next.

<a name="rulesets"></a>
## Rulesets

Rulesets allow multiple constraints to be defined over a single selector

{% highlight css %}
  .selector {
    width: == 100;
  }
{% endhighlight %}

Within a ruleset, constraints are defined on properties using the same syntax as CSS using colon `:` followed by a equality sign.

Rulesets can be nested:

{% highlight css %}
section > article {
   .someclass {
       width: == 100;
    }
}

// is equivalent of
(section > article .someclass)[width] == 100;

{% endhighlight %}

CSS properties can be defined in the rulesets just like in CSS:

{% highlight css %}
div {
   background-color: green;
   width: <= 200;
}
{% endhighlight %}

### Selectors within rulesets

Selectors within ruleset body are scoped to the elements matching the ruleset selector. For example:

{% highlight css %}
div {
  width: <= .widget[width];
}
{% endhighlight %}

`<div>` elements will constrain their width to width of their descendants having the class name `widget`, if they have any.
<a href="http://codepen.io/cbchouinard/pen/yyXPyK" target="_blank">Live example.</a>


`$` combinator makes selectors in ruleset body apply to the root of a document ignoring the nesting:

{% highlight css %}
div {
  width: <= ($ #elm)[width];
}
{% endhighlight %}

`^` combinator makes selectors in ruleset body apply to the elements selected by the parent ruleset:

In this following example '^' will move up to the current `.container` element and will search its descendants
for an element with `elm` id. <a href="http://codepen.io/cbchouinard/pen/yyXPej" target="_blank">Live example.</a>

{% highlight css %}

.container {
  div {
    width: <= (^ #elm)[width];
  }
}

{% endhighlight %}


## Properties

Properties are the variables local to the element. If there is a property in CSS defined with the same name, the computed value will be assigned to element as an inline style in pixels.

Like `$` and `^` combinators, `&` combinator refers to current element matching the ruleset selector. It is implied by the use of `width: ==` property notation.

{% highlight css %}
.container {
  width: == #elm[width];
}

/* It is the same as: */

.container {
  &[width] == #elm[width];
}

{% endhighlight %}

It is possible to constrain custom properties that are not recognized by CSS, but can used in constraints over known CSS properties.


{% highlight css %}

.post {
  custom-property: == &[line-height] * 3;
}

/* equals to */

.post[custom-property] == .post[line-height] * 3;

{% endhighlight %}

This will automatically create a `custom-property` for each element having a `.post` class. The element's `custom-property` will be constrained to be thrice its own `line-height`.

Because of the 2-way binding, changing either `custom-property` or `line-height` will affect the other property of the element.


Properties on special combinators like `&`, `$` or `^` may omit square brackets:

{% highlight css %}

body {
  .container {
    // equate width of a <body> element with width of elements having container class
    &width == ^width; 
  }
}

{% endhighlight %}


<a name="scope"></a>
## Scope

Properties are attached to a specific element:
  * In rulesets, it's an element that matches the selector
  * In topmost level of a stylesheet, it's a `<link>` or `<style>` that defines the stylesheet. 
  * In stylesheet element with `scoped` attribute, topmost variables are attached to the parent element of a stylesheet.

Variables prefixed with `$` combinator are considered global, and can be shared by different stylesheets. 


### Properties in stylesheet

Properties defined at the top level of a stylesheet will be attached to the stylesheet element. Thus each stylesheet provides its own scope. Top level properties are not directly accessible from other stylesheets.

{% highlight css %}
<style type="text/gss">
  varX: == 100;
  varX: == #elm1[width];
</style>

<style type="text/gss">
  varX: == 200;
  varX: == #elm1[width];
</style>
{% endhighlight %}

In this example, `#elm1` will have a width of 100px and `#elm2` will have a width of 200px.
The two `varX` are in different scopes and are therefore indenpendent from each other.
<a href="http://codepen.io/cbchouinard/pen/EaXmRp" target="_blank">Live example.</a>

Global variables prefixed with `$`, are accessible accross stylesheets. In the previous example, using `$varX` instead of `varX` makes constraints operate on the same variable, making the widths of two elements equal. <a href="http://codepen.io/cbchouinard/pen/yyoxxm" target="_blank">Live example.</a> 

Adding a `scoped` attribute to the stylesheet attaches top most properties to the parent element of a stylesheet. If two `scoped` stylesheets share the parent element, they will automatically share the topmost variables. 

The same scoping logic applies to external GSS files.


### Properties in rulesets

Variables defined inside a ruleset define a property on each element that matches the ruleset selector.

{% highlight css %}
.someClass {
  varX: == 100;
  width: == &[varX];
}

.someOtherClass {
  varX: == 100;
  width: == &[varX];

}
{% endhighlight %}

In this case, both rulesets define `varX` property for matching elements. If there's an element that matches both rulesets, it will have both constraints applied over a single property. This may lead to a conflict local to that element. 

The latter constraint will win in case of conflict if element had both classes from the start. Otherwise the class that was added the latest will "win". Strengths can be used to define the importance of each constraint independent from order of changes. <a href="http://codepen.io/cbchouinard/pen/XJgRPq" target="_blank">Live example.</a>


<a name="variables"></a>
### Variables

Variables are properties that dont have explicit scope and can be accessed from inner scopes.  This concept is known as lexical scoping. The scoping is determined by the source code, so it's *static* and does not change in runtime.

We say that topmost scope that defines variable *captures* the variable, making variables in the inner scopes *hoisted*.


{% highlight css %}

<style text='text/gss'>
varX == 100;

.className {
  width: == varX;   // same as &width == ^varX
  varY == &[height];

  #div {
    width: == varX; // same as &width == ^^varX
  }
}
</script>

{% endhighlight %}

If a `varX` was defined as a property on the top level (e.g. `varX: == 100`), the variable would be captured at the `.className` level instead.  


The order of appearance or square brackets around variables have no effect over hoisting:

{% highlight css %}

div {
  .rule {
    [varX] == 200; /* hoisted to parent, same as ^varX*/
  }

  [varX] == 100; /* equivalent to varX == 100; */

{% endhighlight %}


Variables are properties in disguise. If a variable has a name of a CSS property, it will apply the style for its resolved scope element. This fact can be used to define declarative constraints based on the DOM structure.

{% highlight css %}
<style text='text/gss'>
varX = 100;

.wrapper {
  width == varX;

  section {
    width == &height;
  }
}
</script>

{% endhighlight %}

`width` variable in the `.wrapper` ruleset captures `width` variable within `section` ruleset. Therefore an element having `wrapper` class name will have its width equal to height of its descendant sections, if there are any.

Rulesets can be nested arbitarily deep, and the hoisting reference is computed for each variable individually. A variable that was not defined in any of its parent scopes, is considered local and is identical to property. 

{% highlight css %}
div {
  varX == 40; // captured varX 

  .someClass {
    width: == varX;

    .someNestedClass {
        varY == 45;
        width: == varY;  // captured varY
        top: == varX;
    }

    .someOtherNestedClass {
        varY == 60;
        height: == varY;  // captured varY
        width: == varX;
      }
  }
}
{% endhighlight %}

In this case, all nested rulesets will share `varX` variable through parent ruleset. Nested rulesets also define `varY` variables that are not hoisted and act like local properties. <a href="http://codepen.io/cbchouinard/pen/zxzwXJ" target="_blank">Live example.</a>

Only variables capture other variables within inner rulesets. Anything that has explicit scope is considered a property. Properties do not capture and are not hoisted. Examples would be `$global` variables and `&local` variables. `property: ==` notation is the cleanest way to define property in a ruleset:

{% highlight css %}
div {
  varX: == 40; /* property constraint */
  varY == 45; /* variable constraint */

  .someClass {
    /* varX is not hoisted here since on the parent scope varX is a property. */
    /* A new variable varX is there created and scoped to .someClass */
    width: == varX;

    .someNestedClass {
      /* varY is hoisted from the div scope since it's scoped at that level */
      width: == varY;
      /* varX here is the .someClass varX scoped variable */
      top: == varX;
    }
  }
}
{% endhighlight %}

It is possible to opt out of hoisting in the same way by prepending `&` to a variable name, making it a property. 

{% highlight css %}
div {
  varX == 50;

  .className {
    varX: == 60;
    width: == &varX; /*  60 since we are using the property varX */
  }
}
{% endhighlight %}

### Suggested variables

Javascript code can provide numerical values that can be used in constraints. The easiest way to do it, is to pass an object with values to GSS constructor:

{% highlight html %}

<script src="/bower_components/gss/dist/gss.js"></script>
<script type="text/javascript">
  GSS.document = new GSS(document, {"some-width": 400, "some-height": 150});
</script>

<style type="text/gss">

  section[width] == $some-width;
  section[height] == $some-height;

</style>

{% endhighlight %}

Suggested variables are global so they should be accessed with `$` combinator. <a href="http://codepen.io/cbchouinard/pen/pvWMJV" target="_blank">Live example.</a>

External variables are bound in one direction, so their values will not be affected by the solver. It is almost as if there were actual numbers in place of those variables. The difference is that these values can be updated dynamically without much effort on the solver side:

{% highlight html %}
  <script>
    document.onmousemove = (e) {
      GSS.document.solve({ // make mouse movement affect variables
        "some-width": e.clientX,
        "some-height": e.clientY
      })
    }
  </script>
{% endhighlight}


<a name="position"></a>
## Positioning

Elements are positioned relative to the scope element, so its top left corner is considered a (0, 0) point. GSS initialized upon `document`, `<html>`, `<body>` or `<head>` position against the `<html>` element. Global properties like `$left`, `$right`, `$scroll-top` and `$bottom` point to respective properties of `::window`. 

Cassowary is a general purpose solver, so it does not make any assumptions about the positioning or even geometry. If there's nothing that is bound to absolute values like zero or edges of the screen, the whole layout can be solved to be positioned off-screen. Negative `top` and `left` values is a common gotcha in *underconstrained* systems.

### Top

{% highlight css %}

#someElm[top] == 20;

/* equivalent to : */
#someElm[y] == 20;

{% endhighlight %}

Place the top of the element 20px from the top of the page.

### Bottom

{% highlight css %}

#someElm[bottom] == 100;

/* equivalent to : */
#someElm[bottom] == #someElm[top] + #someElm[height];

{% endhighlight %}

Place the bottom of the element 100px from the top of the page.

### Left

{% highlight css %}

#someElm[left] == 20;

/* equivalent to : */
#someElm[x] == 20;

{% endhighlight %}

Place the left of the element 20px from the left of the page.

### Right

{% highlight css %}

#someElm[right] == 100;

/* equivalent to : */
#someElm[rigth] == #someElm[left] + #someElm[width];

{% endhighlight %}

Place the right of the element 100px from the left of the page.

### position

{% highlight css %}
#someElm[position] == 100;

/* equivalent to : */
#someElm[top] == 100;
#somElm[left] == 100;

{% endhighlight %}

### top-left, top-right

{% highlight css %}
#someElm[top-left] == 100;
#otherElm[top-right] == 200;

/* equivalent to : */
#someElm[top] == 100;
#someElm[left] == 100;
#otherElm[top] == 200;
#otherElm[right] == 200;

{% endhighlight %}

Position the `#someElm` top-left corner to be at 100px from the top-left of the page.
Same thing for `#otherElm` excepts its the top-right corner that's been position 200px
from the top-left of the page.

### bottom-left, bottom-right

{% highlight css %}
#someElm[bottom-left] == 100;
#otherElm[bottom-right] == 200;
{% endhighlight %}

Position the `#someElm` bottom-left corner to be at 100px from the top-left of the page.
Same thing for `#otherElm`, excepts its the bottom-right corner that's been position 200px
from the top-left of the page.

### center-x, cx

{% highlight css %}
#someElm[center-x] == 100;

/* you can also use the condense syntax: */
#someElm[cx] == 100;

/* center-x will expand in the following constraints */
#someElm[left] + #someElm[width] / 2 == 100;

{% endhighlight %}

Horizontally place the horizontal center of the element at 100px from the left of the page.

### center-y, cy

{% highlight css %}

#someElm[center-y] == 100;

/* you can also use the condense syntax: */
#someElm[cy] == 100;

/* center-y will expand in the following constraints */
#someElm[top] + #someElm[height] / 2 == 100;

{% endhighlight %}

Place the vertical center of the element 100px from the top of the page.

### Center

{% highlight css %}
#someElm[center] == 100;
{% endhighlight %}

`center` is a 2d property shortcut for constraining both `center-x` and `center-y` at once.

<a name="relativepositionning"></a>


### Relative positioning

Elements that have parents with `position: relative` declared in CSS stylesheet will compute their position ignoring that declaration. Visually the constraints will hold, but the actual `top` and `left` styles assigned for each element will account for the relative positioning.

When `position


{% highlight css %}

<section class="relative-container" style="position: relative">
  <div class="container"></div>
</section>

<section class="relative-container" id="section-two" style="position: relative">
  <div class="container"></div>
</section>

<style type="text/gss">

.relative-container {
  top: == 0;
  left: == 0;

  .container {
    @v |-(&)-| in(^) gap(10);
    height: == 100;
    width: == 100;
  }
}

</style>

{% endhighlight %}

In this example, the `top` and `left` are constrained to be zero wich is the top-left corner of section
elements. By doing so, all position' constraints will be calculated relative to the section element.

With the `position: relative` declared in the `style` attribute, GSS will solve independently each sections which
should results in better performance. <a href="http://codepen.io/cbchouinard/pen/pvwaNN" target="_blank">Live example.</a>

## Dimensions
GSS provides property to constrain the dimension of an element. We've already saw the `width` and `height`.
GSS provides syntax sugar called 2d properties to constrain both height and width of an element as a single property.

{% highlight css %}

.selectorA {
  size: == 200;
}

{% endhighlight %}

## Intrinsic values
When you want to constrain the position of an element GSS needs to know the dimension of the element. For example how could
GSS position an element using the bottom-right property without knowing the height and width of that element.

One way to solve this, would be to constrain the dimension of the element. But what if it had text in it? You'll then need to know the
exact width and height require to display the text. What if that text is dynamic? The element might also be styled using CSS and you
want to get the dimensions of that styling.

In most cases, the constraints will provide those values indirectly regardless of the element's contents. It is possible to make
GSS measure content the values coming from DOM or CSS - be it text, or blocks styled with css.

GSS provides the `intrinsic-` properties which defers to CSS the dimension styling of the element and instruct GSS to measure
the elements using that styling.

{% highlight css %}

  .selectorA {
    width: == &[intrinsic-width];
    height: == &[intrinsic-height];
  }

  .selectorB {
    size: == &[intrinsic-size];
  }

{% endhighlight %}

Once an intrinsic property is used on an element, GSS will evaluate other constraints you defined on the same property but the
calculated value will not be assign to the property because `intrinsic` property makes the property read-only.

For example, if we add a `width` constraint on `.selectorA`, that constraint will be
evaluated by GSS but not applied to the element since `intrinsic-*` have precendence over all other constraints.

<a name="virtuals"></a>
## Virtuals
Virtuals are rectangles you define in GSS that don't have a representation in the DOM. You can contrain DOM element
and other virtuals against the dimension and position of virtuals. Virtual are a practical way to constrain a group of element
without the need for a DOM container element.

{% highlight css %}

  "area" {
    size: == ::window[size] / 2;
    center: == ::window[center];
  }

  #elmA[top-left] == "area"[top-left];
  #elmB[bottom-right] == "area"[top-right];

{% endhighlight %}

As you can see from the previous example, we are constraining `#elmA` and `#elmB` against the virtual element.
<a href="http://codepen.io/cbchouinard/pen/WbOWgB" target="_blank">Live example.</a>

In regards of constraining dimensions and positions, virtuals are no different from DOM element in the sens that you can
declare constraints on them as shown previously. The main difference is that since they don't exist in the DOM, they are
not stylable with CSS. Doing the following will have no effect:

{% highlight css %}

"area" {
  /* Styling virtuals have no effect since they don't exist in the DOM */
  background-color: blue;
}

{% endhighlight %}

### Virtual hoisting
Virtuals follow the same scoping rules as variables. You can do the following:

{% highlight css %}

.className {
  "area"[size] == 200;

  #someElm > div {
    width: == "area"[width]; /* "area" will be hoisted from the .className scope */
  }
}

{% endhighlight %}


### Virtual splat
Virtual splats allow you to create a grid of virtuals. For example, if you want to split the viewport in four equally dimensioned
virtuals you can do the following:

{% highlight css %}


"area1...4" {
  width: == ::window[width] / 2;
  height: == ::window[height] / 2;
}

"area1...2" {
  top: == 0;
  right: == &:next[left];
}

"area3...4" {
  right: == &:next[left];
}

"area1", "area3" {
  top: == &:previous[bottom];
}
"area2", "area4" {
  top: == &:previous[bottom];
}

{% endhighlight %}

Using those virtual boxes, you can now constrain DOM elements against those four boxes. <a href="http://codepen.io/cbchouinard/pen/VYzOPx" target="_blank">Live example.</a>


## Read next
GSS provides conditionnal statements to allow you to do responsive design. Read our [@if @else guide](/guides/ifelse) to learn more.

With only CCSS constraints at your disposal, constraining common layout scenarios quickly becomes tedious. Read our
[VFL guide](/guides/ifelse) to learn how to more efficiently constrain your layout.
