---
uid: selectors
title: GSS Selectors
subtitle: Selectors, combinators, pseudo-classes.
color: b
layout: post
---

## Selectors

In order to apply constraint to element you first need to select them from the DOM. GSS supports
the following list of basic selectors. <a href="http://codepen.io/cbchouinard/pen/Eavbyd" target="_blank">Live example.</a>

#### Elements

{% highlight css %}

  div[width]: == 100;

{% endhighlight %}

GSS supports the `*` selector meaning all element of the page will be selected.

#### Classes

{% highlight css %}

  .className[width]: == 100;

{% endhighlight %}

Using the element's class attribute `<div class='className'></div>` this selector will select
all elements that have the class `className`.

#### ID

{% highlight css %}

  #elementId[width]: == 100;

{% endhighlight %}


## Combinators
Combinators are used to combine basic selectors to allow more fine grained selection of elements.
 <a href="http://codepen.io/cbchouinard/pen/WbEXKd" target="_blank">Live example.</a>

The following combinators can be use in GSS:

#### Union

{% highlight css %}

div, .className {
  width: == 100;
}

/* inline syntax */
(div, .className)[width] == 100;

{% endhighlight %}

For all `div` elements and elements having the `.className` class, a `width` of 100 will be constrained.

#### All descendant elements

{% highlight css %}
div .className {
  width: == 100;
}

/* inline syntax */
(div .className)[width] == 100;
{% endhighlight %}

Select all element having the `className` class define that are descendant of a `div` element.

#### Attribute selector

{% highlight css %}
div.className {
  width: == 100;
}

/* inline syntax */
(div.className)[width] == 100;
{% endhighlight %}

Select all `div` element that have the `className` class.

#### All child elements

{% highlight css %}
div > .className {
  width: == 100;
}

/* inline syntax */
(div > .className)[width] == 100;
{% endhighlight %}

Select all direct child elements having the `className` class of each `div` elements.

#### Next sibling element

{% highlight css %}

div + .className {
  width: == 100;
}

/* inline syntax */
(div + .className)[width] == 100;

{% endhighlight %}

Select the direct succeeding sibling elements of all `div` if those siblings have the `className` class.

#### All direct sibling elements

{% highlight css %}

div ++ .className {
  width: == 100;
}

/* inline syntax */
(div ++ .className)[width] == 100;

{% endhighlight %}

Select the previous and next direct sibling elements of all `div` if those siblings have the `className` class.

#### All succeeding sibling elements
{% highlight css %}
div ~ .className {
  width: == 100;
}

/* inline syntax */
(div ~ .className)[width] == 100;
{% endhighlight %}

Select all succeeding sibling elements of `div` that have the `className` class.

#### All sibling elements

{% highlight css %}

div ~~ .className {
  width: == 100;
}

/* inline syntax */
(div ~~ .className)[width] == 100;

{% endhighlight %}

Select all preceeding and succeeding sibling elements of `div` that have the `className` class.

## Combinators limitation

Combinators requires a selector on both side of the combinator. For example the following is not currently supported:

{% highlight css %}

div ~ {
  top: == 100;
}

{% endhighlight %}

You can use the `*` to get the same results

{% highlight css %}

div ~ * {
  top: == 100;
}

{% endhighlight %}

## Reverse Combinators

For parent-child selector, the reverse combinator `!` allows you to reverse the selector relationship
to child-parent. For sibling selectors, the reverse combinator `!` allows you to go up in the DOM for
the selection. <a href="http://codepen.io/cbchouinard/pen/jELaRK" target="_blank">Live example.</a>

#### All parent elements

{% highlight css %}

  div ! .className {
  	width: == 100;
  }

  /* inline syntax */
  (div ! .className)

{% endhighlight %}

Select elements with the `.className` class that are parents of a `div` element.

#### Direct parent elements

{% highlight css %}

  div !> .className {
  	width: == 100;
  }

{% endhighlight %}

Select elements with the `.className` class that are direct parents of a `div` element.

#### Previous sibling element

{% highlight css %}

  div !+ .className {
  	width: == 100;
  }

{% endhighlight %}

Select the direct previous sibling elements of div elements that have the `className` class.

#### All preceeding sibling elements

{% highlight css %}

  div !~ .className {
  	width: == 100;
  }

{% endhighlight %}


## Pseudo-classes

When using selectors, GSS creates a collection of matching elements and then iterates over those elements
to apply the constraints you've defined against each element of the collection. Pseudo-classes allows you
to further select an element within that collection.

The following pseudo-classes are supported in GSS.

#### :next element in the collection

{% highlight css %}

  div {
  	top: == &:next;
  }

{% endhighlight %}

The `div` selector will create a collection of matching `div` elements. The pseudo-classes `:next` in this example will select
the next `div` in the collection relative to the current div which is represented by `&`.

#### :previous element in the collection

{% highlight css %}

div {
  top: == &:previous;
}

{% endhighlight %}

Like the `:next` pseudo-class but instead of getting the next div in the collection it gets the previous one.

#### :get element in the collection

{% highlight css %}

div > .someClass:get('parentNode') {
  TODO - not sure about this one. Need some testing.
}

{% endhighlight %}

#### First element in the collection

{% highlight css %}

div:first[size] == 100;

{% endhighlight %}

Selects the first div found and add a constraint of 100px on the `size`.

#### Last element in the collection

{% highlight css %}

  div:last[size] == 100;

{% endhighlight %}

Selects the last div found and add a constraint of 100px on the `size`.

## Special pseudo selectors

GSS provides the following special pseudo selectors:

### Parent selector

{% highlight css %}

section {
  .className {
    width: == ^[width];
  }
}

/* Alternative syntax */
.className {
  width: == ::parent[width];
}

{% endhighlight %}

As we've seen previously, GSS will iterate over all selected elements to apply contraints.
When using the `^` pseudo selector you are telling GSS to select the parent element selected in the parent ruleset
of the current selected element. <a href="http://codepen.io/cbchouinard/pen/JoyMpR" target="_blank">Live example.</a>

{% highlight css %}

.className {
  width: == ^^[width];
}

{% endhighlight %}

In the previous example, GSS will access the parent of the parent of the current selected element.

### this selector

{% highlight css %}

.className {
  line-height: == &[font-size] + 10;
}

{% endhighlight %}

Alternative syntaxes:

{% highlight css %}

.className {
  line-height: == ::this[font-size] + 10;
}

.otherClass {
  line-height: == ::[font-size] + 10;
}

{% endhighlight %}

In these example, the line-height of the selected element will by 10px more than the font-size of the element.

### ::window selector

{% highlight css %}

.className {
  width: == ::window[width] / 2;
}

{% endhighlight %}

 The window selector gives you access to the visible part of the page in the browser. The `::window` pseudo selector will not take into
 account the scroll bar if any.

 `::window` pseudo selector is very handy for positionning and dimensionning elements.

### Global scope selector

The global scope allows you to access global variables or select elements from the root of the DOM three when selector from within a ruleset.

{% highlight css %}

.className {
  line-height: == ($ #elm)[line-height];
}

{% endhighlight %}

Tough we do not necessarely recommand this practice, you could declare a global variable within a ruleset like so:

{% highlight css %}

.className {
  $[someVar] == 10;
}

{% endhighlight %}

In this case, the variable `[someVar]` is globally declared eventough it is declare within a ruleset.


## Selector Ruleset Scoping
Selector within ruleset are scoped to that ruleset. [current scope](/guides/constraints#variablesandscope)

TODO - Complete section.

## Selectors and the DOM

The collection of element built from selectors is built according to the DOM elements' order. The elements collection order needs to be understood when using pseudo-classes like in this example:

{% highlight css %}

section, div {
	top: == &:next[top];
}

{% endhighlight %}

In this case, some `div` element can appear in the collection before some `section` element. So `&:next` can return either a `section` element or a `div` element depending on the DOM order.

Depending on your intention, this can make total sense but keep in mind that these constraints will be applied base on the DOM order.


### Inline syntax
All selector combinator can be used inline like the following:

{% highlight css %}
  (div > .className)[width] == 100;
{% endhighlight %}

In this case we're telling GSS to define a constraint on the width of all child element of div having the `.className` class.

### Specificity
The current version of GSS doesn't support specificity on selector.

### Two selectors per expression
GSS limits to two the number of selector in a GSS expression. As for now the following is not supported:

{% highlight css %}
    #div4[width] == #div1[width] + #div2[width] + #div3[width];
{% endhighlight %}

The support for more than 3 selectors in GSS expression will probably be added in a near future but in meantime you can do something like:

{% highlight css %}
[tempSum] = #div1[width] + #div2[width];
#div4[width] == [tempSum] + #div3[width];
{% endhighlight %}
