---
uid: selectors
title: GSS Selectors
subtitle: Selectors, combinators, pseudo-classes.
color: b
layout: post
---

## Selectors

GSS supports the following list of selectors: 

#### Elements

{% highlight css %}

  div[width]: == 100;

{% endhighlight %}

GSS supports the `*` selector meaning all element of the page will be selected.

#### Classes

{% highlight css %}

  .className[width]: == 100;

{% endhighlight %}


#### ID

{% highlight css %}

  #elementId[width]: == 100;

{% endhighlight %}


## Combinators

The following combinators are supported in GSS. 

#### Selectors union

{% highlight css %}

  div, .className {
  	width: == 100;
  }

{% endhighlight %}

For all `div` elements and elements having the `.className` class define, the rule will be applied.

#### All descendant elements

{% highlight css %}
  div .className {
  	width: == 100;
  }
{% endhighlight %}

Select all element having the `className` class define that are descendant of a `div` element.

#### Attribute selector 

{% highlight css %}
  div.className {
    width: == 100;
  }
{% endhighlight %}

Select all div element that have the `className` class.

#### All child elements

{% highlight css %}
  div > .className {
  	width: == 100;
  }
{% endhighlight %}

#### Next element

{% highlight css %}

  div + .className {
  	width: == 100;
  }

{% endhighlight %}

#### All direct sibling elements

{% highlight css %}

  div ++ .className {
  	width: == 100;
  }

{% endhighlight %}

#### All succeeding sibling elements

{% highlight css %}

  div ~ .className {
  	width: == 100;
  }

{% endhighlight %}

#### All sibling elements

{% highlight css %}

  div ~~ .className {
  	width: == 100;
  }

{% endhighlight %}


### Reverse Combinators

For parent-child selector, the reverse combinator `!` allows you to reverse the selector relationship to child-parent.

For sibling selectors, the reverse combinator `!` allows you to go up in the DOM for the selection.

#### All parent elements

{% highlight css %}

  div ! .className {
  	width: == 100;
  }

{% endhighlight %}

Select elements with the `.className` class that are parents of a `div` element.

#### Direct parent elements

{% highlight css %}

  div !> .className {
  	width: == 100;
  }

{% endhighlight %}

Select elements with the `.className` class that are direct parents of a `div` element.

#### Previous element

{% highlight css %}

  div !+ .className {
  	width: == 100;
  }

{% endhighlight %}

#### All preceeding sibling elements

{% highlight css %}

  div !~ .className {
  	width: == 100;
  }

{% endhighlight %}

##### Combinators limitation

Combinators requires a selector on both side of the combinator. For example the following is not currently supported: 


## Pseudo-classes

The following pseudo-classes are supported in GSS. The selectors and combinator will create a collection of matching element. Pseudo-classes allows you to further select element within that collection.

#### Next element in the collection

{% highlight css %}

  div {
  	top: == &:next;
  }

{% endhighlight %}

The `div` selector will create a collection of matching `div` elements. The pseudo-classes `:next` in this example will select the second `div` in the collection. 

#### Previous element in the collection

{% highlight css %}

  todo - find a good example.

{% endhighlight %}

#### Last element in the collection

{% highlight css %}

  div:last[size] == 100;

{% endhighlight %}

We define a constraint on the size of the last div in the document.

### Selectors and the DOM

The collection of element built from selectors is built according to the DOM elements' order. The elements collection order needs to be understood when using pseudo-classes like in this example:

{% highlight css %} 

section, div {
	top: == &:next[top];
}

{% endhighlight %}

In this case, some `div` element can appear in the collection before some `section` element. So `&:next` can return either a `section` element or a `div` element depending on the DOM order.

Depending on your intention, this can make total sense but keep in mind that these constraints will be applied base on the DOM order. 

### Inline syntax
All selector combinator can be used inline like the following: 

{% highlight css %}
  (div > .className)[width] == 100;
{% endhighlight %}

In this case we're telling GSS to define a constraint on the width of all child element of div having the `.className` class. 

### Specificity
The current version of GSS doesn't support specificity on selector. 

### Two selectors per expression
GSS limits to two the number of selector in a GSS expression. As for now the following is not supported:

{% highlight css %}
    #div4[width] == #div1[width] + #div2[width] + #div3[width];
{% endhighlight %}

The support for more than 3 selectors in GSS expression will probably be added in a near future but in meantime you can do something like: 

{% highlight css %}
    [tempSum] = #div1[width] + #div2[width];
    #div4[width] == [tempSum] + #div3[width];
{% endhighlight %}

