---
uid: selectors
title: GSS Selectors
subtitle: Selectors, combinators, pseudo-classes.
color: b
layout: post
---

## Selectors

In order to apply constraint to element you first need to select them from the DOM. GSS supports
the following list of basic selectors. <a href="http://codepen.io/cbchouinard/pen/Eavbyd" target="_blank">Live example.</a>

#### Elements

{% highlight css %}

  div[width]: == 100;

{% endhighlight %}

GSS supports the `*` selector meaning all element of the page will be selected.

#### Classes

{% highlight css %}

  .className[width]: == 100;

{% endhighlight %}

Using the element's class attribute `<div class='className'></div>` this selector will select
all elements that have the class `className`.

#### ID

{% highlight css %}

  #elementId[width]: == 100;

{% endhighlight %}


## Combinators

The following selector combinators are supported in GSS.

#### union

{% highlight css %}

div, .className {
  width: == 100;
}

/* inline syntax */
(div, .className)[width] == 100;

{% endhighlight %}

For all `div` elements and elements having the `.className` class, a `width` of 100 will be constrained.

#### All descendant elements

{% highlight css %}
div .className {
  width: == 100;
}

/* inline syntax */
(div .className)[width] == 100;
{% endhighlight %}

Select all element having the `className` class define that are descendant of a `div` element.

#### Attribute selector

{% highlight css %}
div.className {
  width: == 100;
}

/* inline syntax */
(div.className)[width] == 100;
{% endhighlight %}

Select all `div` element that have the `className` class.

#### All child elements

{% highlight css %}
div > .className {
  width: == 100;
}

/* inline syntax */
(div > .className)[width] == 100;
{% endhighlight %}

Select all children elements of each `div` elements.

#### Next sibling element

{% highlight css %}

div + .className {
  width: == 100;
}

/* inline syntax */
(div + .className)[width] == 100;

{% endhighlight %}

Select the next sibling element of all `div` if the sibling has the `className` class.

#### All direct sibling elements

{% highlight css %}

div ++ .className {
  width: == 100;
}

/* inline syntax */
(div ++ .className)[width] == 100;

{% endhighlight %}

Select the previous and next sibling element of all `div` if they have the `className` class.

#### All succeeding sibling elements

{% highlight css %}

  div ~ .className {
  	width: == 100;
  }

{% endhighlight %}

Select all succeeding sibling elements of div that have the `className` class.

#### All sibling elements

{% highlight css %}

div ~~ .className {
  width: == 100;
}

/* inline syntax */
(div ~~ .className)[width] == 100;

{% endhighlight %}

Select all preceeding and succeeding sibling elements of `div` that have the `className` class.

### Reverse Combinators

For parent-child selector, the reverse combinator `!` allows you to reverse the selector relationship to child-parent.

For sibling selectors, the reverse combinator `!` allows you to go up in the DOM for the selection.

#### All parent elements

{% highlight css %}

  div ! .className {
  	width: == 100;
  }

{% endhighlight %}

Select elements with the `.className` class that are parents of a `div` element.

#### Direct parent elements

{% highlight css %}

  div !> .className {
  	width: == 100;
  }

{% endhighlight %}

Select elements with the `.className` class that are direct parents of a `div` element.

#### Previous element

{% highlight css %}

  div !+ .className {
  	width: == 100;
  }

{% endhighlight %}

#### All preceeding sibling elements

{% highlight css %}

  div !~ .className {
  	width: == 100;
  }

{% endhighlight %}

##### Combinators limitation

Combinators requires a selector on both side of the combinator. For example the following is not currently supported:

{% highlight css %}

div ~ {
  top: == 100;
}

{% endhighlight %}

## Pseudo-classes

The following pseudo-classes are supported in GSS. The selectors and combinator will create a collection of matching element. Pseudo-classes allows you to further select element within that collection.

#### :next element in the collection

{% highlight css %}

  div {
  	top: == &:next;
  }

{% endhighlight %}

The `div` selector will create a collection of matching `div` elements. The pseudo-classes `:next` in this example will select the second `div` in the collection.

#### :previous element in the collection

{% highlight css %}

div {
  top: == &:previous;
}

{% endhighlight %}

#### :get element in the collection

{% highlight css %}

div > .someClass:get('parentNode') {
  TODO - not sure about this one. Need some testing.
}

{% endhighlight %}


#### Last element in the collection

{% highlight css %}

  div:last[size] == 100;

{% endhighlight %}

We define a constraint on the size of the last div in the document.

## Pseudo selector
GSS provides the following pseudo selectors:

### Parent selector

{% highlight css %}

.className {
  width: == ^[width];
}

{% endhighlight %}

Alternative syntax:

{% highlight css %}

.className {
  width: == ::parent[width];
}

{% endhighlight %}

Assigned the width of the elements having `.className` class to the width of their parent element.

You can also go up the chain of parents element by stacking the `^` selector:

{% highlight css %}

.className {
  width: == ^^[width];
}

{% endhighlight %}

In this example, the width of the element having the `.className` class will be equal the width of the parent of its parent.

### this selector

{% highlight css %}

.className {
  line-height: == &[font-size] + 10;
}

{% endhighlight %}

Alternative syntaxes:

{% highlight css %}

.className {
  line-height: == ::this[font-size] + 10;
}

.otherClass {
  line-height: == ::[font-size] + 10;
}

{% endhighlight %}

In these example, the line-height of the selected element will by 10px more than the font-size of the element.

### ::window selector

{% highlight css %}

.className {
  width: == ::window[width] / 2;
}

{% endhighlight %}

 The window selector gives you access to the visible part of the page in the browser. The `::window` pseudo selector will not take into
 account the scroll bar if any.

 `::window` pseudo selector is very handy for positionning and dimensionning elements.

### Global scope selector

The global scope allows you to access global variables or select elements from the root of the DOM three when selector from within a ruleset.

{% highlight css %}

.className {
  line-height: == ($ #elm)[line-height];
}

{% endhighlight %}

Tough we do not necessarely recommand this practice, you could declare a global variable within a ruleset like so:

{% highlight css %}

.className {
  $[someVar] == 10;
}

{% endhighlight %}

In this case, the variable `[someVar]` is globally declared eventough it is declare within a ruleset.


## Selector Ruleset Scoping
Selector within ruleset are scoped to that ruleset. [current scope](/guides/constraints#variablesandscope)

TODO - Complete section.

## Selectors and the DOM

The collection of element built from selectors is built according to the DOM elements' order. The elements collection order needs to be understood when using pseudo-classes like in this example:

{% highlight css %}

section, div {
	top: == &:next[top];
}

{% endhighlight %}

In this case, some `div` element can appear in the collection before some `section` element. So `&:next` can return either a `section` element or a `div` element depending on the DOM order.

Depending on your intention, this can make total sense but keep in mind that these constraints will be applied base on the DOM order.


### Inline syntax
All selector combinator can be used inline like the following:

{% highlight css %}
  (div > .className)[width] == 100;
{% endhighlight %}

In this case we're telling GSS to define a constraint on the width of all child element of div having the `.className` class.

### Specificity
The current version of GSS doesn't support specificity on selector.

### Two selectors per expression
GSS limits to two the number of selector in a GSS expression. As for now the following is not supported:

{% highlight css %}
    #div4[width] == #div1[width] + #div2[width] + #div3[width];
{% endhighlight %}

The support for more than 3 selectors in GSS expression will probably be added in a near future but in meantime you can do something like:

{% highlight css %}
[tempSum] = #div1[width] + #div2[width];
#div4[width] == [tempSum] + #div3[width];
{% endhighlight %}
