---
uid: constraints
title: Constraints Style Sheets
subtitle: Constraints, Selectors, Rules, Variables & Scope, Dimensions & Positions, Instrinsic Values and Virtuals.
color: b
layout: post
---
Soon after the W3C introduced Cascading Style Sheets, [Greg Badros](http://www.badros.com/greg/), the author of the Cassowary Constraint
Solver & [recently retired Facebook VP](http://allthingsd.com/20130920/facebook-engineering-and-products-vp-greg-badros-to-leave-company/),
proposed [Constraint CSS (CCSS)](http://www.cs.washington.edu/research/constraints/web/ccss-uwtr.pdf) as a general solution for CSS layout.
Back in '99 Badros demonstrated *responsive* layouts with CCSS that today's designers still can't reproduce without grinding out piles of JavaScript.
For more than a decade, no one seemed to take notice outside academia... Until Apple implemented Cassowary & Greg's pioneering concepts in its new
AutoLayout engine with the launch of OS X Lion. Despite the evolutionary leap for app developers, web designer's have had to settle
with [float-based](http://www.sitepoint.com/give-floats-the-flick-in-css-layouts/) & table-based layouts that have remained unimproved to this day.

> "We should contemplate how very, very far behind the web platform is in making it delightful to build the sorts of things that are work-a-day in native environments." <a href="http://infrequently.org/2012/02/misdirection/">Alex Russell</a>

The foundation of GSS is a modernized implementation of CCSS.  From CCSS primitives other, more exotic layout API's can and are accomplished.

## Constraints, the basics

Constraints express [relationships between variables](#constraintsaretwoways) that [may or may not hold](#mayofmaynothold). You can constrain any
numerical style property of an element, not just its position & size.

For example, if I want all paragraph tags to have line-height greater than 16px and less than 1/12th the size of the window:

{% highlight css %}

p[line-height] >= 16;
p[line-height] <= ::window[height] / 12;

{% endhighlight %}

### Constraints declaration

Let's go through the syntax for declaring a constraint:

`p[line-height] >= 16;`

+ `p` is the selector. This constraint will apply to every `p` tag in the page.
+ `[]` is the style property selector.
+ `line-height` is the style property for which a value will be calculated by GSS.
+ `>=` defines an inequality constraint. You can declare inequality and equality constraint.
+ `16` is the numerical value for the constraint in pixel unit. The default unit in GSS are pixels.

<a href="http://codepen.io/cbchouinard/pen/OPmdVL" target="_blank">Live example</a>

<a name="constraintsaretwoways"></a>
### Constraints are 2-ways
Do not confuse an equality constraint with your everyday variable assignment. For example, in a vanilla programming paradigm:

{% highlight javascript %}

// vanilla programming

x = y;
y = 10
x = 100;

// x => 100, y => 10

{% endhighlight %}

x will be 100, and y will be 10.  With constraint programming, equality constraints are two-way, so:

{% highlight javascript %}

// constraint programming

x == y;
x == 100;
y >= 10;

// x => 100, y => 100

{% endhighlight %}

x and y have a constraint to be equal, so x and y will be 100.

Constraints are incrementally added to a `solver`, then the solver computes a feasible & optimal solution to all the constraints.  With constraint programming you input the *what* you want to happen, not *how* it will happen. With procedural programming, you focus on the *how*.  This makes constraints a perfect fit for empowering declarative languages like CSS.


<a name="mayofmaynothold"></a>
### Constraints May or may not hold
GSS will find the best solution that satisfies the constraints you've defined. By default, GSS use what we call soft constraints which means that it is preferred but not required that certain constraints be satisfied.

For example:

{% highlight css %}

#gss[width] == 200;
#cassowary[width] == 200;
#gss[width] + #cassowary[width] == 350;

{% endhighlight %}

In the previous example, we're asking GSS to give the `#GSS` and `#cassowary` elements a width of 200px and we
later declare a constraint for the sum of these two elements to be equal to 350px. In this case, one of these
two constraint will not hold. <a href="http://codepen.io/cbchouinard/pen/XJROdV" target="_blank">Live example.</a>

As we'll see next, you can influence the constraints solving by given more information to GSS about your intent.

<a name="strenghts"></a>
### Strenghts
Strenghts allows you to guide GSS in your layout intention by giving the GSS constraints solver more details about which constraints you prioritize.

Stronger constraints completely overcome weaker ones - this is the phenomena of the [Constraint Hierarchy](http://www.cs.washington.edu/research/constraints/theory/hierarchies-92.html).  Strengths are declared in the same fashion of CSS's `!important`:

{% highlight css %}

/* Stronger constraints completely overcome weaker ones */

#light[years] == 100 !weak;
#light[years] == 200 !medium;
#light[years] == 300 !strong;

/* #light[years] will be 300 */

{% endhighlight %}

There are 4 levels of built-in strength:

- `!weak`
- `!medium`
- `!strong`
- `!require`

`!medium` is the default for all constraints when no strenght is explicitly defined.

Using the [May or may not hold](#mayofmaynothold) example we saw previously,
we'll now give a stronger strenght to each individual `width` constraints to
make sure they overcome the sum constraints: <a href="http://codepen.io/cbchouinard/pen/bNRbQg" target="_blank">Live example.</a>

#### !require strenght
`!require` is a special strength that guarantees the constraint will hold, otherwise everything breaks.

**Pro Tip** Use `!require` carefully & sparingly. `!require`'s quickly lead to systems where
all required constraints cannot be satisfied.

For example, the following GSS expressions will be unsolvable:

{% highlight css %}

#gss[width] == 200 !require;
#cassowary[width] == 200 !require;
#gss[width] + #cassowary[width] == 350 !require;

{% endhighlight %}

We're asking GSS to find a solution where the widths of the #gss and #cassowary element must be 200px
and their sum must be 350px which is impossible.

### Constraints order
Generally speaking, later constraint statements are more powerful than earlier ones. There could be exception
to this behavior as we'll see in the following sections.

Taking the [May or may not hold example](#mayofmaynothold) we saw previously, by changing the order of the constraints you'll get a
different result. <a href="http://codepen.io/cbchouinard/pen/rawBRr" target="_blank">Live example.</a>

<a name="lineararithmetic"></a>
## Linear Arithmetic

Cassowary only allows for "Linear Arithmetic" constraints, you can do simple math operations like `+`, `-`, `*` and `/`,
but all expressions must be linear (of the form `y = mx + b`).  Basically, you can do most things except multiply or
divide two constraint variables.  <a href="http://codepen.io/cbchouinard/pen/MYvOWO" target="_blank">Live example.</a>

{% highlight css %}

/* this is not linear & will throw an error */

#box1[width] / #box1[height] == #box2[width] / #2box[height];

{% endhighlight %}

We wish we could go non-linear, but we can't because math.

## Units of measurement
Default unit in GSS are pixels. GSS also supports the following units:

{% highlight css %}
#em[width] == 10em;
#pourcentage[width] == 10%;
{% endhighlight %}

<a name="selectors"></a>
## Selectors

GSS supports many selectors to allow you to select elements for which you want to declare constraints.

{% highlight css %}
.className > #someElm ~ div {
  width: == 100;
}
{% endhighlight %}

Since we have a lot of selector we've dedicated a guide for them. We invite you to scroll all the way
down in that guide, there's some useful information there: [GSS Selectors Guide](/guides/selectors)

Note that this guide is refering to [ruleset](rulesets) which are covered next.

<a name="rulesets"></a>
## Rulesets
GSS allows you to declare constraint using ruleset as with CSS:

{% highlight css %}
  .Selector {
    width: == 100;
  }
{% endhighlight %}

Within a ruleset, constraints are defined on properties using the same syntax as CSS using the colon `:`.

Rulesets can be nested:

{% highlight css %}
Section > article {
   .someclass {
       width: == 100;
    }
}
{% endhighlight %}

You can defined CSS alongside GSS in rules:

{% highlight css %}
div {
   background-color: green;
   width: <= 200;
}
{% endhighlight %}

**Pro Tip** We recommand keeping your styling with CSS and layout with GSS in seperates style elements or files.

### Rulesets and selectors
Rulesets will scope the nested selectors to all descendant of the ruleset elements. For example:

{% highlight css %}
div {
  width: <= #elm[width];
}
{% endhighlight %}

In this example, GSS will search for a descendant element of a div having an element with `id='elm'`.
Its important to understand that the constraints will be define independantly for each instance of
`div` found. For example, if there're two `div` on the page, the first one having a inner `#elm`
element but not the other, the first `div` will have a constraint declare but not the second one since
it doesn't contain a `#elm` element. <a href="http://codepen.io/cbchouinard/pen/yyXPyK" target="_blank">Live example.</a>


If you want to select and element from the entire DOM you need to do the following:

{% highlight css %}
div {
  width: <= ($ #elm)[width];
}
{% endhighlight %}

If you want to select an element from the element's parent you can use the `^` pseudo selector:

{% highlight css %}

.container {
  div {
    width: <= (^ #elm)[width];
  }
}

{% endhighlight %}

In this example `(^ #elm)` will search for a `#elm` element contained in the current element having
the `.container` class. <a href="http://codepen.io/cbchouinard/pen/yyXPej" target="_blank">Live example.</a>

<a name="variablesandscope"></a>
## Variables and scope
Declaring a variable in GSS is as simple as using it:

{% highlight css %}
[var1] == 100;
{% endhighlight %}


Square brackets are optional. The following GSS is equivalent to the previous one:
{% highlight css %}
var1 == 100;
{% endhighlight %}

### Global variable
Global variables can be define using the `$` symbol.

{% highlight css %}
$var1 == 100;
{% endhighlight %}

### Scope
GSS will scope variables base on the location they are first declared. A variable can be scoped
within a style element, within a ruleset or globally for the entire document.

{% highlight css %}
  .Selector {
    width: == 100;
  }
{% endhighlight %}

#### Style sheet
When declaring a variable, by default the variable will be scoped within the style element.
In other words, if you have more than one stylesheet and both have a variable with the same
name, these two variables will be in two different scope and therefore are independant of each other.

{% highlight css %}
<style type="text/gss">
  varX == 100;
  #elm1[width] == varX;
</style>

<style type="text/gss">
  varX == 200;
  #elm2[width] == varX;
</style>
{% endhighlight %}

In this example, `#elm1` will have a width of 100px and `#elm2` will have a width of 200px.
The two `varX` are in distinct scope and are therefore indenpendant from each other.
<a href="http://codepen.io/cbchouinard/pen/EaXmRp" target="_blank">Live example.</a>

#### Ruleset
Variable define inside ruleset are scoped to the ruleset.

{% highlight css %}
.someClass {
  varX == 100;
  width: == varX;
}

.someOtherClass {
  varX == 200;
  width: == varX;
}
{% endhighlight %}

In this example, each `varX` is in a different scope and are therefore independant from
each other. <a href="http://codepen.io/cbchouinard/pen/XJgRPq" target="_blank">Live example.</a>

### Hoisting
When using a variable in GSS, before creating the variable GSS will look on parent'
scopes to see if there's an existing variable with the same name.

For example:

{% highlight css %}
div {
  varX == 40;

  .someClass {
    width: == varX;

    .someNestedClass {
        varY == 45;
        width: == varY;
        top: == varX;
    }

    .someOtherNestedClass {
        varY == 60;
        height: == varY;
        width: == varX;
      }
  }
}
{% endhighlight %}

In this case, `varX` used in the nested selectors is hoisted from the `div` scope. Internally, GSS will go up the
scope tree using the parent pseudo selector `^varX`, if no variable are found at that level GSS will do `^^varX`
and so on until it finds a variable or until it reach the root scope in which case no variable exist so GSS will
create a new on on the scope where it was declared.

`varY` is been declare in sibling rules therefore it will be define in those two scope and these are two distinct
and independent variables. <a href="http://codepen.io/cbchouinard/pen/zxzwXJ" target="_blank">Live example.</a>

#### Prevent a variable from being hoisted
If you don't want your variable to be hoisted to nested scopes you can declare you variable
with a `:` after the variable name:

{% highlight css %}
div {
  varX: == 40;

  .someClass {
    width: == varX; // ^varX will be unreachable.

    .someNestedClass {
      varY == 45;
      width: == varY;
      top: == varX;
    }
  }
}
{% endhighlight %}


#### Override hoisted variables locally
You can override a variable locally within the scope of a ruleset using the `&` pseudo selector:

{% highlight css %}
div {
  varX == 50;

  .className {
    &varX == 60;
    width: == &varX;
  }
}
{% endhighlight %}

In this example, `&[varX]` will be scoped locally to the `.className` ruleset. The `varX` defined
under the `div` selector.

Note the use of the `&` in `width: == &varX;`, without it hoisting would still occur and reference the
equivalent of `^varX` which is constraint to be equal to 50.


## Positions constraints
GSS provide properties to quickly constraint the dimensions and positions of elements. The top-left corner
of the page as the coordinate `x = left = 0, y = top = 0`. When constraining positions in GSS you will
always constraints them base on the `0px, 0px` coordinate of the page.

### Top

{% highlight css %}

  #someElm[top] == 20;

{% endhighlight %}

Place the top of the element 20px from the top of the page. Top is the equivalent of the following:

{% highlight css %}

#someElm[y] == 20;

{% endhighlight %}


### Bottom

{% highlight css %}

#someElm[bottom] == 100;

{% endhighlight %}

Place the bottom of the element 100px from the top of the page. `bottom` is the equivalent of:

{% highlight css %}

#someElm[bottom] == #someElm[top] + #someElm[height];

{% endhighlight %}


### Left

{% highlight css %}

#someElm[left] == 20;

{% endhighlight %}

Place the left of the element 20px from the left of the page. Left is the equivalent of:

{% highlight css %}

#someElm[x] == 20;

{% endhighlight %}


### Right

{% highlight css %}

#someElm[right] == 100;

{% endhighlight %}

Place the right of the element 100px from the left of the page. `right` is the equivalent of:

{% highlight css %}

#someElm[rigth] == #someElm[left] + #someElm[width];

{% endhighlight %}

### position

{% highlight css %}
#someElm[position] == 100;
{% endhighlight %}

Constraining the `position` is the equivalent of constraining:

{% highlight css %}
#someElm[top] == 100;
#somElm[left] == 100;
{% endhighlight %}

### top-left, top-right

{% highlight css %}
#someElm[top-left] == 100;
#otherElm[top-right] == 200;
{% endhighlight %}

Position the `#someElm` top-left corner to be at 100px from the top-left of the page.
Same thing for `#otherElm` excepts its the top-right corner that's been position 200px
from the top-left of the page.


### bottom-left, bottom-right

{% highlight css %}
#someElm[bottom-left] == 100;
#otherElm[bottom-right] == 200;
{% endhighlight %}

Position the `#someElm` bottom-left corner to be at 100px from the top-left of the page.
Same thing for `#otherElm` excepts its the bottom-right corner that's been position 200px
from the top-left of the page.

### center-x, cx

{% highlight css %}
#someElm[center-x] == 100;

// you can also use the condense syntax:
#someElm[cx] == 100;

{% endhighlight %}

Place the horizontal center of the element 100px from the left of the page.

### center-y, cy

{% highlight css %}

#someElm[center-y] == 100;

// you can also use the condense syntax:
#someElm[cy] == 100;

{% endhighlight %}

Place the vertical center of the element 100px from the top of the page.

### Center

{% highlight css %}
#someElm[center] == 100;
{% endhighlight %}

`center` is a 2d property shortcut for doing that will constraint both
`center-x` and `center-y` to be 100px from the top-left corner of the page.

### Relatively positionned parents.

GSS deals with relative parents in two distinct way. One being when the parent `position: relative` property
is declared in a CSS ruleset, the other is when the `position: relative` is declare in the `style` attribute of
the element.

#### position: relative in ruleset
Even if the elements your constraining are placed within an element having the CSS property `position: relative`,
the constraints will calculate absolute position agains the top-left corner of the page.

If you look at the calculated values, you'll see that they account for their relative parent position but are
positionned according to the top-left of the page.


#### position: relative in style attribute

**Pro Tip** If you have within your site some pages with multiple sections, GSS will need calculate the constraints for
all the section at once in order to find the best possible solution. In some case, that can lead to
performance issue. If that's the case, you can position each section using regular CSS by declaring then as
follow:

{% highlight css %}

<section class="relative-container" style="position: relative">
  <div class="container"></div>
</section>

<section class="relative-container" id="section-two" style="position: relative">
  <div class="container"></div>
</section>

<style type="text/gss">

.relative-container {
  x: == 0;
  y: == 0;

  .container {
    @v |-(&)-| in(^) gap(10);
    height: == 100;
    width: == 100;
  }
}

</style>

{% endhighlight %}

In this example, we are constraining `x` and `y` to be zero wich is the top-left corner of the section
element. By doing so, all position constraints will be calculated relative to the section element.

With the `position: relative` declare in the `style` attribute, GSS will solve independently each sections which
will results in better performance. <a href="http://codepen.io/cbchouinard/pen/pvwaNN" target="_blank">Live example.</a>

## Dimensions
GSS provides property to constraints the dimension of an element. We've already saw the `width` and `height`. You can use the 2D dimension
property to set them both the width and the height at the same time:

{% highlight css %}

.SelectorA {
  size: == 200;
}

{% endhighlight %}

## Intrinsic values

When you want to constraint the position of an element GSS needs to know the dimension of the element. For example how could
GSS position an element using the bottom-right property without knowing the height and width of that element.

One way to solve this, would be to constraint the dimension of the element. But what if it had text in it? You'll then need to know the
exact width and height require to display the text. What if that text is dynamic?

GSS provides the `intrinsic-` properties to get the dimension of the element defined by the text occupying the element and/or the
CSS styling the element.

{% highlight css %}

  .SelectorA {
    width: == &[intrinsic-width];
    height: == &[intrinsic-height];
  }

  .SelectorB {
    size: == &[intrinsic-size];
  }

{% endhighlight %}

Once an intrinsic value is constrained on a property, GSS will not evaluate other constraints you define on the same property.

For example if we add a `width` constraint on `.SelectorA` this constraint will be ignored by GSS since `intrinsic-*` have total
precendence over all other constraints.

## Virtuals
Virtuals are a very interesting concept that allows you to constraints elements against `virtual` element that don't actually exists in the DOM.


{% highlight css %}

  "virtual" {
    size: == ::window[size] / 2;
    center: == ::window[center];
  }

  #elmA[top-left] == "virtual"[top-left];
  #elmB[bottom-right] == "virtual"[top-right];

{% endhighlight %}

In this example we are constraining `#elmA` and `#elmB` against the virtual element.

Virtuals are very handy with [VFL](/guides/vfl-guide).
