---
uid: constraints
title: Constraints Style Sheets
subtitle: Constraints, Selectors, Rules, Variables & Scope, Dimensions & Positions, Instrinsic Values and Virtuals.
color: b
layout: post
---

Constraints allows you to design great layout.

## Constraints

Constraints express [relationships between variables](#constraintsaretwoways) that [may or may not hold](#mayofmaynothold). You can constrain any numerical style property of an element, not just its position & size.

For example, if I want all paragraph tags to have line-height greater than 16px and less than 1/12th the size of the window:

{% highlight css %}

p[line-height] >= 16;
p[line-height] <= ::window[height] / 12;

{% endhighlight %}

### Constraints declaration

Let's go through the syntax for declaring a constraint: 

`p[line-height] >= 16;`

+ `p` is the selector. This constraint will apply to every `p` tag in the page. 
+ `[]` is the style property selector. 
+ `line-height` is the style property for which a value will be calculated by GSS. 
+ `>=` defines an inequality constraint. With GSS you can define inequality and equality constraint.
+ `16` is the numerical value for the constraint in pixel unit. As for now, GSS support the pixel unit only. 

<a href="http://codepen.io/cbchouinard/pen/NPdgwm" target="_blank">Here's an example to play with constraints declaration</a>

<a name="constraintsaretwoways"></a>
### Constraints are 2-ways
Do not confuse an equality constraint with your everyday variable assignment. For example, in a vanilla programming paradigm:

{% highlight javascript %}

// vanilla programming

x = y;
y = 10
x = 100;

// x => 100, y => 10

{% endhighlight %}

x will be 100, and y will be 10.  With constraint programming, equality constraints are two-way, so:

{% highlight javascript %}

// constraint programming

x == y;
x == 100;
y >= 10;

// x => 100, y => 100

{% endhighlight %}

x and y have a constraint to be equal, so x and y will be 100.

Constraints are incrementally added to a `solver`, then the solver computes a feasible & optimal solution to all the constraints.  With constraint programming you input the *what* you want to happen, not *how* it will happen. With procedural programming, you focus on the *how*.  This makes constraints a perfect fit for empowering declarative languages like CSS.


<a name="mayofmaynothold"></a>
### Constraints May or may not hold
GSS will find the best solution that satisfies the constraints you've defined. By default, GSS use what we call soft constraints which means that it is preferred but not required that certain constraints be satisfied.

For example:

{% highlight css %}

Code a good example for this.

{% endhighlight %}

<a href="http://codepen.io/cbchouinard/pen/NPdgwm" target="_blank">todo - May or may not hold sample</a>

Once solved, the div might have a size other than 10 if that's the best size for div that GSS found in order to satisfy the most constraints you've define. You can guide GSS in your constraints intention using [Strenghts](http://codepen.io/cbchouinard/pen/NPdgwm).

### Strenghts
Strenghts allows you to guide GSS in your layout intention by giving the GSS constraints solver more details about what you want. 

Stronger constraints completely overcome weaker ones - this is the phenomena of the [Constraint Hierarchy](http://www.cs.washington.edu/research/constraints/theory/hierarchies-92.html).  Strengths are declared in the same fashion of CSS's `!important`:

{% highlight css %}

/* Stronger constraints completely overcome weaker ones */

#light[years] == 100 !weak;
#light[years] == 200 !medium;
#light[years] == 300 !strong;

/* #light[years] will be 300 */

{% endhighlight %}

There are 4 levels of built-in strength:

- `!weak`
- `!medium`
- `!strong`
- `!require`

All constraints have a strength.  `!medium` is the default for all constraints.

`!require` is a special strength that guarantees the constraint will hold, otherwise everything breaks.

**Pro Tip** Use `!require` carefully & sparingly.  `!require`'s quickly lead to systems where all required constraints cannot be satisfied.

### Constraints order
Generally speaking, later constraint statements are more powerful than earlier ones. There could be exception to this behavior as well see in the following sections.

## Selectors

GSS supports the following selectors: [view all selectors](/guides/selectors)

{% highlight css %}

  .Selector[width]: == 100;

{% endhighlight %}

### Specificity

TODO - How does GSS deals with selector specificities?

### Two selectors per expression

GSS limits to two the number of selector in a GSS expression.

TODO - Test the behavior when defining more than 2.

## Rules

GSS allows you to declare constraint using ruleset as with CSS:

{% highlight css %}
  .Selector {
    width: == 100;
  }
{% endhighlight %}

Within a ruleset, constraints are defined on properties using the same syntax as CSS using the colon `:`.  

Rulesets can be nested:

{% highlight css %}
Section > article {
   .someclass {
       width: == 100;
    }
}
{% endhighlight %}

You can defined CSS alongside GSS in rules:

{% highlight css %}
div {
   background-color: red;
   width: <= 200;
}
{% endhighlight %}

**Pro Tip** We recommand keeping your styling with CSS and layout with GSS in seperates style elements or files.


## Variables and scope

Declaring a variable in GSS is as simple as using it:

{% highlight css %}
[var1] == 100;
{% endhighlight %}

This just define a variable name var1 and assign the value 100 pixels to it.

### Scope

GSS will scope variable base on the location they are first declared. A variable can be scoped globally, within a style element
or within a ruleset. 

{% highlight css %}
  .Selector {
    width: == 100;
  }
{% endhighlight %}

#### Style sheet
When declaring a variable, by default the variable will be scope within the style element. In other words, if you have more than
one stylesheet and both have a variable with the same name, these two variables will be in two different scope and therefore are independant of each other.

#### Ruleset
Variable define within rules and accessible to declaration within the rule set and not outside.


#### Hoisting
When using a variable GSS, before creating the variable GSS will look on parent scope to see if there's an existing variable with the same name. 

For example:

{% highlight css %}
div {
  [var3] == 40;
    .someClass {
      width: == [var3];

      .someNestedClass {
        [varX] == 45;
        width: == [var3];
        top: == [varX];
      }

      .someOtherNestedClass {
        [varX] == 60;
        height: == [varX];
        width: == [var3];
      }
    }
}
{% endhighlight %}

In this case, var3 used in the nested classes is hoisted from the div scope. Internally GSS will go up the scope three using the parent selector `^[var3]`, `^^[var3]` and so on until it finds a variable or until it reach the root scope in which case no variable exist so GSS will create a new on on the scope where it was declared.

`[varX]` is been declare in sibling rules therefore it will be define in those two scope and these are two distinct and independent variables.


## Dimensions and positions

Dimensions and positions documentation here.

{% highlight css %}

.Selector {
  width: == 100;
}

{% endhighlight %}


## Intrinsic values

Intrinsic values documentation here.

{% highlight css %}

  .Selector {
    width: == 100;
  }

{% endhighlight %}

## Virtuals

Virtual documentation here.

{% highlight css %}

  .Selector {
    width: == 100;
  }

{% endhighlight %}
