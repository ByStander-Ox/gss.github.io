---
uid: CCSS
title: Constraint CSS
subtitle: LAY IT OUT LIKE IT'S 1999
color: b
layout: post
---
Soon after the W3C introduced Cascading Style Sheets, [Greg Badros](http://www.badros.com/greg/), the author of the Cassowary Constraint
Solver & [recently retired Facebook VP](http://allthingsd.com/20130920/facebook-engineering-and-products-vp-greg-badros-to-leave-company/),
proposed [Constraint CSS (CCSS)](http://www.cs.washington.edu/research/constraints/web/ccss-uwtr.pdf) as a general solution for CSS layout.
Back in '99 Badros demonstrated *responsive* layouts with CCSS that today's designers still can't reproduce without grinding out piles of JavaScript.
For more than a decade, no one seemed to take notice outside academia... Until Apple implemented Cassowary & Greg's pioneering concepts in its new
AutoLayout engine with the launch of OS X Lion. Despite the evolutionary leap for app developers, web designer's have had to settle
with [float-based](http://www.sitepoint.com/give-floats-the-flick-in-css-layouts/) & table-based layouts that have remained unimproved to this day.

> "We should contemplate how very, very far behind the web platform is in making it delightful to build the sorts of things that are work-a-day in native environments." <a href="http://infrequently.org/2012/02/misdirection/">Alex Russell</a>

The foundation of GSS is a modernized implementation of CCSS.  From CCSS primitives other, more exotic layout API's can and are accomplished.

## Constraints, the basics

Constraints express [relationships between variables](#constraintsaretwoways) that [may or may not hold](#mayofmaynothold). You can constrain any
numerical style property of an element, not just its position & size.

For example, if I want all paragraph tags to have line-height greater than 16px and less than 1/12th the size of the window:

{% highlight css %}

p[line-height] >= 16;
p[line-height] <= ::window[height] / 12;

{% endhighlight %}

### Constraints declaration

Let's go through the syntax for declaring a constraint:

`p[line-height] >= 16;`

+ `p` is the selector. This constraint will apply to every `p` tag in the page.
+ `[]` is the style property selector.
+ `line-height` is the style property for which a value will be calculated by GSS.
+ `>=` defines an inequality constraint. You can declare inequality and equality constraint.
+ `16` is the numerical value for the constraint in pixel unit. The default unit in GSS are pixels.

<a href="http://codepen.io/cbchouinard/pen/OPmdVL" target="_blank">Live example</a>

<a name="constraintsaretwoways"></a>
### Constraints are 2-ways
Do not confuse an equality constraint with your everyday variable assignment. For example, in a vanilla programming paradigm:

{% highlight javascript %}

// vanilla programming

x = y;
y = 10
x = 100;

// x => 100, y => 10

{% endhighlight %}

x will be 100, and y will be 10.  With constraint programming, equality constraints are two-way, so:

{% highlight javascript %}

// constraint programming

x == y;
x == 100;
y >= 10;

// x => 100, y => 100

{% endhighlight %}

x and y have a constraint to be equal, so x and y will be 100.

Constraints are incrementally added to a `solver`, then the solver computes a feasible & optimal solution to all the constraints.
With constraint programming you input the *what* you want to happen, not *how* it will happen. With procedural programming,
you focus on the *how*.  This makes constraints a perfect fit for empowering declarative languages like CSS.


<a name="mayofmaynothold"></a>
### Constraints May or may not hold
GSS will find the best solution that satisfies the constraints you've defined. By default, GSS use what we call soft constraints,
which means that it is preferred but not required that certain constraints be satisfied.

For example:

{% highlight css %}

#gss[width] == 200;
#cassowary[width] == 200;
#gss[width] + #cassowary[width] == 350;

{% endhighlight %}

In the previous example, we're asking GSS to give the `#GSS` and `#cassowary` elements a width of 200px and we
later constraint the sum of these two elements to be equal to 350px. In this case, one of these
two constraint will not hold. <a href="http://codepen.io/cbchouinard/pen/XJROdV" target="_blank">Live example.</a>

As we'll see next, you can influence the constraints solving by given more information to GSS about your intent.

<a name="strengths"></a>
## Strengths
Strengths allow you to guide GSS in your layout intention by giving the GSS constraints solver more details about which
constraints you prioritize.

Stronger constraints completely overcome weaker ones - this is the phenomena of the [Constraint Hierarchy](http://www.cs.washington.edu/research/constraints/theory/hierarchies-92.html).  Strengths are declared in the same fashion of CSS's `!important`:

{% highlight css %}

/* Stronger constraints completely overcome weaker ones */

#light[years] == 100 !weak;
#light[years] == 200 !medium;
#light[years] == 300 !strong;

/* #light[years] will be 300 */

{% endhighlight %}

There are 4 levels of built-in strength:

- `!weak`
- `!medium`
- `!strong`
- `!require`

`!medium` is the default for all constraints when no strenght is explicitly defined.

Using the [May or may not hold](#mayofmaynothold) example we saw previously,
we'll now give a stronger strength to each individual `width` constraints to
make sure they overcome the sum constraints: <a href="http://codepen.io/cbchouinard/pen/bNRbQg" target="_blank">Live example.</a>

#### !require strength
`!require` is a special strength that guarantees the constraint will hold, otherwise everything breaks.

**Pro Tip** Use `!require` carefully & sparingly. `!require`'s quickly lead to systems where
all required constraints cannot be satisfied in which case the GSS engine will throw an error.

For example, the following GSS constraints will be unsolvable and throw an exception:

{% highlight css %}

#gss[width] == 200 !require;
#cassowary[width] == 200 !require;
#gss[width] + #cassowary[width] == 350 !require;

{% endhighlight %}

We're asking GSS to find a solution where the widths of the #gss and #cassowary element must be 200px
and their sum must be 350px which is impossible.

### Constraints order
Generally speaking, later constraint declarations are more powerful than earlier ones. There are exceptions to this behavior,
as we'll see in the following sections.

Taking the [May or may not hold example](#mayofmaynothold) we saw previously, by changing the order of the constraints you'll get a
different result. <a href="http://codepen.io/cbchouinard/pen/rawBRr" target="_blank">Live example.</a>

<a name="lineararithmetic"></a>
## Linear Arithmetic

Cassowary, which is the constraints solving algorithm used by GSS, only allows for "Linear Arithmetic" constraints, you can do simple
math operations like `+`, `-`, `*` and `/`, but all expressions must be linear (of the form `y = mx + b`).  Basically, you can do
most things except multiply or divide two constraint variables.  <a href="http://codepen.io/cbchouinard/pen/MYvOWO" target="_blank">Live example.</a>

{% highlight css %}

/* this is not linear & will throw an error */

#box1[width] / #box2[height] == varX;

{% endhighlight %}

## Units of measurement
The default unit of measurement in GSS is pixel. GSS also supports the following units:

{% highlight css %}
em /* use the font size of the element */
rem /* use the font size of the html element */
vh /* viewport height */
vw /* viewport width */
vmax /* the greatest value between vh or vw */
vmin /* the lowest value between vh or vw */
cm /* centimeter */
mm /* millimeter */
in /* inches */
{% endhighlight %}

<a name="selectors"></a>
## Selectors

GSS supports many selectors allowing you to select elements for which you want to declare constraints on.

{% highlight css %}
.className > #someElm ~ div {
  width: == 100;
}
{% endhighlight %}

Since GSS has a lot of selectors, we've dedicated a guide for them. We invite you to read all of it since there are some useful
information at the bottom: [GSS Selectors Guide](/guides/selectors) \*

\* Note that this guide is refering to [rulesets](rulesets) which are covered next.

<a name="rulesets"></a>
## Rulesets
With GSS you can declare constraint using rulesets as with CSS:

{% highlight css %}
  .Selector {
    width: == 100;
  }
{% endhighlight %}

Within a ruleset, constraints are defined on properties using the same syntax as CSS using the colon `:`.

Rulesets can be nested:

{% highlight css %}
Section > article {
   .someclass {
       width: == 100;
    }
}
{% endhighlight %}

You can defined CSS alongside GSS in rules:

{% highlight css %}
div {
   background-color: green;
   width: <= 200;
}
{% endhighlight %}

### Rulesets and selectors
Rulesets will scope the nested selectors to the descendants elements of the ruleset elements. For example:

{% highlight css %}
div {
  width: <= #elm[width];
}
{% endhighlight %}

In this example, GSS will iterate over each `div` found and will search for an element with `id='elm'` in the current `div`
descendant elements. Its important to understand that constraints will be define independantly for each selected instance of
`div`. For example, if there are two `div` selected and the first one has a child `#elm`
element but not the other, the first `div` will have a constraint declare but not the second one.
<a href="http://codepen.io/cbchouinard/pen/yyXPyK" target="_blank">Live example.</a>

If you want to select and element from the GSS root element, you need to do the following:

{% highlight css %}
div {
  width: <= ($ #elm)[width];
}
{% endhighlight %}

If you want to select an element within the parent's child elements, you can use the `^` pseudo selector:

{% highlight css %}

.container {
  div {
    width: <= (^ #elm)[width];
  }
}

{% endhighlight %}

In this example `(^ #elm)` will search for an `id=#elm` element contained in the current `.container` parent's
element. <a href="http://codepen.io/cbchouinard/pen/yyXPej" target="_blank">Live example.</a>

## Properties
All the previous examples constrained CSS properties like `width` or `line-height`. But you can also
constraint non-CSS property using GSS.

{% highlight css %}

.post {
  custom-properties: == &[line-height] * 3;
}

/* you can also declare custom properties using inline syntax as well */
.post[custom-properties] == .post[line-height] * 3;

{% endhighlight %}

This will automatically create a `[custom-properties]` property for each element having a `.post` class. That property
will be constrained to be equal to three time the line-height property..

Don't forget this relationship is 2-way, so further constraining a
post's [custom-properties] can affect its line-height, which can be remedied by taking advantage of the
"Constraint Hierarchy" with [Strengths](#strengths).

<a name="variables"></a>
## Constraints Variables
In addition to properties, GSS allows you to declare variables. You can access variables declared in parent rulesets
or at the root of the stylesheet like this:

{% highlight css %}

<style text='text/gss'>
varX = 100;

.className {
  width: == varX;
  varY == &[height];

  #div {
    width: == varX;
  }
}
</script>

{% endhighlight %}

Variables are hoisted and can be access child scope. You can learn more about variable's hoisting and scoping in [scope section](#scope).


## CSS property name
Now that we've seen properties and variables you can do some interesting things by using CSS property as variables. For example you
can declare constraints on CSS properties of parent scope:

{% highlight css %}
<style text='text/gss'>
varX = 100;

.className {
  width == varX;

  #someElm {
    width == &[height];
  }
}
</script>

{% endhighlight %}

Since `width` in the `.className` ruleset is used as a variable and not a property, it is hoisted. Therefore,
the constraint on the `width` declared in `#someElm` ruleset will affect the `.className` width and not the
`#someElm` `width`.

### Global variables
Global variables can be define using the `$` symbol.

{% highlight css %}
$var1 == 100;
{% endhighlight %}

You can access global scope variables from everywhere using the `$`.

<a name="scope"></a>
## Scope
GSS will scope variables base on their top most location. A variable can be scoped
within a style element, within a ruleset or globally for the entire document.

{% highlight css %}
  .Selector {
    width: == 100;
  }
{% endhighlight %}

In the following example, `varX` used within `.selector` will be hoisted since it is declare in a parent scope.
The order doesn't matter, GSS will search for the top most variable declaration.

{% highlight css %}
  .selector {
    width: == varX;
  }

  varX == 100;
{% endhighlight %}

#### Style sheet
When declaring a variable, by default the variable will be scoped within the style element.
In other words, if you have more than one stylesheet and both have a variable with the same
name, these two variables will be in two different scope and therefore are independant of each other.

{% highlight css %}
<style type="text/gss">
  varX == 100;
  #elm1[width] == varX;
</style>

<style type="text/gss">
  varX == 200;
  #elm2[width] == varX;
</style>
{% endhighlight %}

In this example, `#elm1` will have a width of 100px and `#elm2` will have a width of 200px.
The two `varX` are in distinct scope and are therefore indenpendant from each other.
<a href="http://codepen.io/cbchouinard/pen/EaXmRp" target="_blank">Live example.</a>

If we would have use a global variable for `varX` then the two constrained elements would have
had the same width. <a href="http://codepen.io/cbchouinard/pen/yyoxxm" target="_blank">Live example.</a>

#### Ruleset
Variables defined inside a ruleset are scoped to that ruleset.

{% highlight css %}
.someClass {
  varX == 100;
  width: == varX;
}

.someOtherClass {
  varX == 200;
  width: == varX;
}
{% endhighlight %}

In this example, each `varX` is in a different scope and are therefore independant from
each other. <a href="http://codepen.io/cbchouinard/pen/XJgRPq" target="_blank">Live example.</a>

### Hoisting
When using a variable in GSS, before creating the variable, GSS will look on parent
scopes to see if there's an existing variable with the same name.

For example:

{% highlight css %}
div {
  varX == 40;

  .someClass {
    width: == varX;

    .someNestedClass {
        varY == 45;
        width: == varY;
        top: == varX;
    }

    .someOtherNestedClass {
        varY == 60;
        height: == varY;
        width: == varX;
      }
  }
}
{% endhighlight %}

In this case, `varX` used in the nested rulesets is hoisted from the `div` scope. Internally, GSS will go up the
scope tree using the parent pseudo selector `^varX`, if no variable is found at that level, GSS will do `^^varX`
and so on until it finds a variable or until it reach the root scope, at which point, if GSS didn't find a variable it
will create a new one on the scope where it was declared.

`varY` is been declared in two sibling rulesets. In this case, two distinct variables will be created and scoped to their
respective ruleset. <a href="http://codepen.io/cbchouinard/pen/zxzwXJ" target="_blank">Live example.</a>

#### Properties are not hoisted
Only variables are hoisted. Since properties aren't hoisted, they cannot be access from child scope.

{% highlight css %}
div {
  varX: == 40; /* property constraint */
  varY == 45; /* variable constraint */

  .someClass {
    /* varX is not hoisted here since on the parent scope varX is a property and not a variable. */
    /* A new variable varX is there created and scoped to .someClass */
    width: == varX;

    .someNestedClass {
      /* varY here is hoisted from the div scope since a varY variable is scoped at that level */
      width: == varY;
      /* varX here is the .someClass varX scoped variable */
      top: == varX;
    }
  }
}
{% endhighlight %}

#### Property and variable with the same name
If you declare a property having the same name as a hoisted variable, you need to use the `&` selector to
access the property otherwise you'll get the hoisted variable.

{% highlight css %}
div {
  varX == 50;

  .className {
    varX: == 60;
    width: == &[varX]; /*  60 since we are using the .className property varX */
  }
}
{% endhighlight %}

## Positions constraints
Position in GSS will always be relative to the element in which you instantiated the GSS engine. For example,
if you instantiate the GSS engine in the `html`, `head` or `body` element, then elements will be `absolute` positionned
from `x = left = 0, y = top = 0`. It's also possible to [positionning element relative to a container element](#relativepositionning)
as well see later.

GSS provide properties to quickly constrain the dimensions and positions of elements. For example, assuming the `body` is the root
element for GSS, the `$[top-left]` property of the root element will be `x = left = 0, y = top = 0`.

If you're under constraining your elements, GSS might find a solution where negative coordinates are the solution. In that
case you need to declare more constraints.

The following documentation assume the GSS engine was declared in the `body` element so we are positionning elements from the
top-left corner of the page `x=0, y=0`.

### Top

{% highlight css %}

#someElm[top] == 20;

/* equivalent to : */
#someElm[y] == 20;

{% endhighlight %}

Place the top of the element 20px from the top of the page.

### Bottom

{% highlight css %}

#someElm[bottom] == 100;

/* equivalent to : */
#someElm[bottom] == #someElm[top] + #someElm[height];

{% endhighlight %}

Place the bottom of the element 100px from the top of the page.

### Left

{% highlight css %}

#someElm[left] == 20;

/* equivalent to : */
#someElm[x] == 20;

{% endhighlight %}

Place the left of the element 20px from the left of the page. Left is the equivalent of:

### Right

{% highlight css %}

#someElm[right] == 100;

/* equivalent to : */
#someElm[rigth] == #someElm[left] + #someElm[width];

{% endhighlight %}

Place the right of the element 100px from the left of the page.

### position

{% highlight css %}
#someElm[position] == 100;

/* equivalent to : */
#someElm[top] == 100;
#somElm[left] == 100;

{% endhighlight %}

### top-left, top-right

{% highlight css %}
#someElm[top-left] == 100;
#otherElm[top-right] == 200;

/* equivalent to : */
#someElm[top] == 100;
#someElm[left] == 100;
#otherElm[top] == 200;
#otherElm[right] == 200;

{% endhighlight %}

Position the `#someElm` top-left corner to be at 100px from the top-left of the page.
Same thing for `#otherElm` excepts its the top-right corner that's been position 200px
from the top-left of the page.

### bottom-left, bottom-right

{% highlight css %}
#someElm[bottom-left] == 100;
#otherElm[bottom-right] == 200;
{% endhighlight %}

Position the `#someElm` bottom-left corner to be at 100px from the top-left of the page.
Same thing for `#otherElm`, excepts its the bottom-right corner that's been position 200px
from the top-left of the page.

### center-x, cx

{% highlight css %}
#someElm[center-x] == 100;

/* you can also use the condense syntax: */
#someElm[cx] == 100;

/* center-x will expand in the following constraints */
#someElm[left] + #someElm[width] / 2 == 100;

{% endhighlight %}

Horizontally place the horizontal center of the element at 100px from the left of the page.

### center-y, cy

{% highlight css %}

#someElm[center-y] == 100;

/* you can also use the condense syntax: */
#someElm[cy] == 100;

/* center-y will expand in the following constraints */
#someElm[top] + #someElm[height] / 2 == 100;

{% endhighlight %}

Place the vertical center of the element 100px from the top of the page.

### Center

{% highlight css %}
#someElm[center] == 100;
{% endhighlight %}

`center` is a 2d property shortcut for doing constraining both `center-x` and `center-y` at once.

<a name="relativepositionning"></a>
### Relatively positionned parents.

GSS deals with relative parents in two distinct way. One being when the parent `position: relative` property
is declared in a CSS ruleset, the other is when the `position: relative` is declare in the `style` attribute of
the element.

#### position: relative in ruleset
Even if the elements your constraining are placed within an element having the CSS property `position: relative`,
the constraints will calculate absolute position agains the top-left corner of the page.

If you look at the calculated values, you'll see that they account for their relative parent position but are
positionned according to the top-left of the page.


#### position: relative in style attribute
When you are dealing with a very large page composed of hundreds of constraints, GSS will need to evaluate all constraints in order
to find a solution for them.

You can split the calculation of solution by element's container, like `section` element for example. To do so,
add a `style='position: relative'` so GSS will evaluate sections independantly of each other resulting in faster solution
evaluation.

{% highlight css %}

<section class="relative-container" style="position: relative">
  <div class="container"></div>
</section>

<section class="relative-container" id="section-two" style="position: relative">
  <div class="container"></div>
</section>

<style type="text/gss">

.relative-container {
  x: == 0;
  y: == 0;

  .container {
    @v |-(&)-| in(^) gap(10);
    height: == 100;
    width: == 100;
  }
}

</style>

{% endhighlight %}

In this example, we are constraining `x` and `y` to be zero wich is the top-left corner of the section
element. By doing so, all position constraints will be calculated relative to the section element.

With the `position: relative` declared in the `style` attribute, GSS will solve independently each sections which
should results in better performance. <a href="http://codepen.io/cbchouinard/pen/pvwaNN" target="_blank">Live example.</a>

## Dimensions
GSS provides property to constraints the dimension of an element. We've already saw the `width` and `height`. You can use the
2D dimension property to set them both the width and the height at the same time:

{% highlight css %}

.SelectorA {
  size: == 200;
}

{% endhighlight %}

## Intrinsic values
When you want to constraint the position of an element GSS needs to know the dimension of the element. For example how could
GSS position an element using the bottom-right property without knowing the height and width of that element.

One way to solve this, would be to constrain the dimension of the element. But what if it had text in it? You'll then need to know the
exact width and height require to display the text. What if that text is dynamic? The element might also be styled using CSS and you
want to get the dimensions of that styling.

GSS provides the `intrinsic-` properties which defers to CSS the dimension styling of the element.

{% highlight css %}

  .SelectorA {
    width: == &[intrinsic-width];
    height: == &[intrinsic-height];
  }

  .SelectorB {
    size: == &[intrinsic-size];
  }

{% endhighlight %}

Once an intrinsic constraint is declared on a property, GSS will evaluate other constraints you define on the same property but will
not apply the calculated value to the element. For example, if we add a `width` constraint on `.SelectorA`, that constraint will be
evaluated by GSS but not applied to the element since `intrinsic-*` have precendence over all other constraints.

## Virtuals
Virtuals are boxes you define in GSS that don't exists in the DOM but against which you can constraint DOM element. Virtual are a
practical way to apply constraints a group of element without the need to add a container element to the DOM.

{% highlight css %}

  "area" {
    size: == ::window[size] / 2;
    center: == ::window[center];
  }

  #elmA[top-left] == "area"[top-left];
  #elmB[bottom-right] == "area"[top-right];

{% endhighlight %}

As you can see from the previous example, we are constraining `#elmA` and `#elmB` against the virtual element.
<a href="http://codepen.io/cbchouinard/pen/WbOWgB" target="_blank">Live example.</a>

In regards of constraining dimensions and positions, virtuals are no different from DOM element in the sens that you can
declare constraints on them as shown previously. The only difference is, since they don't exist in the DOM, they are
not stylable with CSS. Doing the following will have no effect:

{% highlight css %}

"area" {
  /* Styling virtuals have no effect since they don't exist in the DOM */
  background-color: blue;
}

{% endhighlight %}

### Virtual hoisting
GSS virtual are treated as variables and are therefore hoisted. You can do the following:

{% highlight css %}

.className {
  "area"[size] == 200;

  #someElm > div {
    width: == "area"[width]; /* "area" will be hoisted from the .className scope */
  }
}

{% endhighlight %}


### Virtual splat
Virtual splats allow you to create a grid of virtuals. For example, if you want to split the viewport in four equally dimensioned
virtuals you can do the following:

{% highlight css %}


"area1...4" {
  width: == ::window[width] / 2;
  height: == ::window[height] / 2;
}

"area1...2" {
  top: == 0;
  right: == &:next[left];
}

"area3...4" {
  right: == &:next[left];
}

"area1", "area3" {
  top: == &:previous[bottom];
}
"area2", "area4" {
  top: == &:previous[bottom];
}

{% endhighlight %}

Using those virtual boxes, you can now constrain DOM elements against those four boxes. <a href="http://codepen.io/cbchouinard/pen/VYzOPx" target="_blank">Live example.</a>


## Read next
GSS provides conditionnal statements to allow you to do responsive design. Read our [@if @else guide](/guides/ifelse) to learn more.

With only CCSS constraints at your disposal, constraining common layout scenarios quickly becomes tedious. Read our
[VFL guide](/guides/ifelse) to learn how to more efficiently constrain your layout.
